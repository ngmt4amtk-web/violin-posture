<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ViolinPosture - ãƒã‚¤ã‚ªãƒªãƒ³å§¿å‹¢åˆ†æ</title>
<style>
/* ============================================================
   Stitch Design System â€” ViolinPosture
   Glass morphism + Neon glow + Dark palette
   ============================================================ */

:root {
  /* Backgrounds */
  --bg: #121214;
  --bg-card: #1e293b;
  --card: #1e293b;
  --card-dark: #1e293b;
  --card-border: rgba(255,255,255,0.08);

  /* Accent */
  --green: #00FF94;
  --yellow: #FFE600;
  --red: #FF2E2E;
  --blue: #38bdf8;
  --purple: #a78bfa;
  --cyan: #22d3ee;

  /* Text */
  --text: #f8fafc;
  --text-dim: #94a3b8;

  /* Glass */
  --glass-bg: rgba(30,41,59,0.7);
  --glass-border: rgba(255,255,255,0.08);
  --glass-blur: blur(12px);

  /* Radius */
  --radius-sm: 6px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-xl: 16px;
}

/* ---- Reset ---- */
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

body {
  font-family: 'Noto Sans JP', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow-x: hidden;
  min-height: 100vh;
  -webkit-text-size-adjust: 100%;
  line-height: 1.6;
}

/* ============================================================
   Loading Screen
   ============================================================ */
.loading-screen {
  position: fixed; inset: 0; z-index: 1000;
  background: var(--bg);
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  transition: opacity 0.5s ease;
}
.loading-screen.hidden { opacity: 0; pointer-events: none; }
.loading-spinner {
  width: 48px; height: 48px;
  border: 3px solid var(--card-border);
  border-top-color: var(--blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text {
  margin-top: 16px; color: var(--text-dim);
  font-size: 14px; font-family: 'Inter', sans-serif;
}
.loading-progress {
  margin-top: 8px; color: var(--blue);
  font-size: 12px; font-family: 'Roboto Mono', monospace;
}

/* ============================================================
   Header
   ============================================================ */
header {
  padding: 12px 16px 8px;
  display: flex; align-items: center; justify-content: space-between;
  border-bottom: 1px solid var(--glass-border);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  background: var(--glass-bg);
}
header h1 {
  font-size: 16px; font-weight: 700;
  letter-spacing: 0.5px;
  font-family: 'Inter', sans-serif;
}
header h1 span { color: var(--blue); }
.header-badge {
  font-size: 9px; padding: 2px 8px;
  background: var(--blue); color: #0f172a;
  border-radius: 8px; font-weight: 700;
  letter-spacing: 0.3px;
}

/* ---- View mode toggle ---- */
.view-toggle {
  display: flex; border-radius: 20px;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  overflow: hidden;
}
.view-toggle-btn {
  font-size: 10px; padding: 4px 12px;
  cursor: pointer; white-space: nowrap;
  transition: all 0.25s ease; font-weight: 600;
  color: var(--text-dim); border: none; background: none;
  line-height: 1.2; font-family: 'Inter', sans-serif;
}
.view-toggle-btn.active {
  background: var(--blue); color: #0f172a;
  box-shadow: 0 0 8px rgba(56,189,248,0.4);
}

/* ============================================================
   Screen System
   ============================================================ */
.screen { display: none; }
.screen.active { display: block; }

/* ============================================================
   S1: Focus Area Cards
   ============================================================ */
.focus-fullscan {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--blue);
  border-radius: var(--radius-xl);
  padding: 18px 16px; margin: 0 16px 8px;
  cursor: pointer;
  display: flex; align-items: center; gap: 14px;
  transition: all 0.25s ease;
  box-shadow: 0 0 20px rgba(56,189,248,0.1);
}
.focus-fullscan:active { transform: scale(0.97); }
.focus-fullscan .fs-icon { font-size: 36px; flex-shrink: 0; }
.focus-fullscan .fs-text { flex: 1; }
.focus-fullscan .fs-label {
  font-size: 15px; font-weight: 800; color: var(--blue);
  text-shadow: 0 0 10px rgba(56,189,248,0.3);
}
.focus-fullscan .fs-desc {
  font-size: 11px; color: var(--text-dim);
  margin-top: 2px; line-height: 1.4;
}
.focus-fullscan .fs-arrow {
  font-size: 20px; color: var(--blue); flex-shrink: 0;
}

.focus-grid {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 10px; padding: 16px;
}
.focus-card {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: 16px; cursor: pointer;
  transition: all 0.25s ease; text-align: center;
}
.focus-card:hover {
  border-color: rgba(56,189,248,0.3);
  box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}
.focus-card:active { transform: scale(0.96); }
.focus-card .focus-icon { font-size: 32px; margin-bottom: 8px; }
.focus-card .focus-label {
  font-size: 14px; font-weight: 700;
  margin-bottom: 4px; color: var(--text);
}
.focus-card .focus-desc {
  font-size: 11px; color: var(--text-dim); line-height: 1.4;
}
.focus-card:last-child { grid-column: 1 / -1; }

.report-area-btn {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: 12px; margin-top: 8px;
  cursor: pointer;
  display: flex; align-items: center; justify-content: space-between;
  transition: all 0.25s ease;
}
.report-area-btn:hover { border-color: rgba(56,189,248,0.3); }
.report-area-btn:active { transform: scale(0.97); }
.report-area-btn .rab-left { display: flex; align-items: center; gap: 10px; }
.report-area-btn .rab-icon { font-size: 20px; }
.report-area-btn .rab-name { font-size: 13px; font-weight: 700; }
.report-area-btn .rab-score {
  font-size: 12px; font-weight: 600;
  font-family: 'Roboto Mono', monospace;
}

/* ============================================================
   S2: Camera Guide
   ============================================================ */
.guide-content { padding: 16px; }
.guide-angle-box {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: 20px; margin-bottom: 12px; text-align: center;
}
.guide-angle-box svg { max-width: 200px; margin: 0 auto 12px; display: block; }
.guide-angle-title {
  font-size: 18px; font-weight: 700; margin-bottom: 4px;
  font-family: 'Inter', sans-serif;
}
.guide-angle-sub { font-size: 12px; color: var(--text-dim); }
.guide-tips {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: 14px; margin-bottom: 12px;
}
.guide-tips h3 { font-size: 13px; color: var(--blue); margin-bottom: 8px; }
.guide-tips li {
  font-size: 12px; color: var(--text-dim);
  line-height: 1.6; margin-left: 16px;
}
.guide-btn-row { padding: 0 16px 16px; }

/* ============================================================
   Camera Section
   ============================================================ */
.camera-section {
  position: relative; width: 100%;
  aspect-ratio: 4/3;
  background: #000;
  overflow: hidden;
}
#video, #overlay {
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%;
  object-fit: cover;
}
#overlay { pointer-events: none; }
.mirror { transform: scaleX(-1); -webkit-transform: scaleX(-1); }

/* ---- FPS badge ---- */
.fps-badge {
  position: absolute; top: 8px; left: 8px;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: var(--cyan);
  font-size: 11px; padding: 3px 8px;
  border-radius: var(--radius-sm);
  font-family: 'Roboto Mono', monospace;
  border: 1px solid rgba(255,255,255,0.06);
  z-index: 10;
}

/* ---- Recording badge ---- */
.recording-badge {
  position: absolute; top: 8px; right: 8px;
  background: rgba(255,46,46,0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: #fff;
  font-size: 11px; padding: 3px 10px;
  border-radius: var(--radius-sm);
  font-weight: 700; font-family: 'Inter', sans-serif;
  z-index: 10; display: none;
  animation: pulse 1s infinite;
}
@keyframes pulse { 50% { opacity: 0.5; } }

/* ---- PiP Camera ---- */
.camera-pip {
  position: fixed; top: 12px; right: 12px;
  width: 140px; height: 105px;
  border-radius: var(--radius-md); overflow: hidden;
  z-index: 100;
  box-shadow: 0 4px 24px rgba(0,0,0,0.6), 0 0 12px rgba(56,189,248,0.2);
  border: 2px solid var(--blue);
  display: none; cursor: pointer;
}
.camera-pip video, .camera-pip canvas {
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; object-fit: cover;
}
.camera-pip canvas { pointer-events: none; }

/* ============================================================
   Measurement Overlay (15 sec)
   ============================================================ */
.measure-overlay {
  position: absolute; inset: 0; z-index: 20;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  pointer-events: none;
}
.measure-countdown {
  font-size: 72px; font-weight: 800; color: #fff;
  font-family: 'Roboto Mono', monospace;
  text-shadow: 0 0 30px rgba(56,189,248,0.5), 0 2px 20px rgba(0,0,0,0.8);
}
.measure-progress {
  position: absolute; bottom: 0; left: 0; right: 0;
  height: 4px; background: rgba(255,255,255,0.15);
}
.measure-progress-fill {
  height: 100%; background: var(--blue);
  transition: width 0.1s linear;
  box-shadow: 0 0 8px rgba(56,189,248,0.6);
}
.measure-timer {
  position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: #fff;
  font-size: 14px; font-weight: 700;
  padding: 4px 16px; border-radius: 20px;
  font-family: 'Roboto Mono', monospace;
  border: 1px solid rgba(255,255,255,0.08);
}

/* ============================================================
   Readiness Check Overlay
   ============================================================ */
.readiness-overlay {
  position: absolute; inset: 0; z-index: 25;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}
.readiness-title {
  font-size: 15px; font-weight: 700; color: #fff;
  margin-bottom: 12px;
  text-shadow: 0 1px 8px rgba(0,0,0,0.8);
  font-family: 'Inter', sans-serif;
}
.readiness-checks {
  display: flex; flex-direction: column; gap: 6px;
  background: rgba(18,18,20,0.75);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg); padding: 14px 18px;
  min-width: 180px;
}
.readiness-item {
  display: flex; align-items: center; gap: 8px;
  font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.4);
  transition: color 0.2s, transform 0.2s;
  font-family: 'Inter', sans-serif;
}
.readiness-item.pass {
  color: var(--green);
  transform: scale(1.03);
  text-shadow: 0 0 10px rgba(0,255,148,0.4);
}
.readiness-item .ri-icon { width: 18px; text-align: center; font-size: 15px; }
.readiness-hint {
  margin-top: 10px; font-size: 11px;
  color: rgba(255,255,255,0.6);
  text-shadow: 0 1px 4px rgba(0,0,0,0.8);
  text-align: center; max-width: 220px;
}
.readiness-ok {
  font-size: 48px; font-weight: 800; color: var(--green);
  text-shadow: 0 0 40px rgba(0,255,148,0.6);
  animation: readinessOkPulse 0.4s ease-out;
}
@keyframes readinessOkPulse {
  0% { transform: scale(0.5); opacity: 0; }
  60% { transform: scale(1.2); }
  100% { transform: scale(1); opacity: 1; }
}
.btn-cancel-readiness {
  pointer-events: auto; margin-top: 12px;
  font-size: 12px; padding: 6px 20px;
  background: rgba(255,255,255,0.1);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.15);
  color: #fff; border-radius: 8px; cursor: pointer;
  transition: all 0.2s;
  font-family: 'Inter', sans-serif;
}
.btn-cancel-readiness:hover {
  background: rgba(255,255,255,0.18);
}

/* ============================================================
   RULA Bar
   ============================================================ */
.rula-bar {
  width: 100%; padding: 8px 16px;
  display: flex; align-items: center; gap: 10px;
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border-bottom: 1px solid var(--glass-border);
}
.rula-label {
  font-size: 11px; color: var(--text-dim);
  white-space: nowrap; font-family: 'Inter', sans-serif;
}
.rula-track {
  flex: 1; height: 6px;
  background: rgba(255,255,255,0.06);
  border-radius: 3px; overflow: hidden;
  position: relative;
}
.rula-fill {
  height: 100%; border-radius: 3px;
  transition: width 0.3s ease, background 0.3s ease;
  width: 0%;
  box-shadow: 0 0 6px currentColor;
}
.rula-score {
  font-size: 13px; font-weight: 700;
  font-family: 'Roboto Mono', monospace;
  min-width: 28px; text-align: right;
}
.rula-level {
  font-size: 10px; padding: 2px 8px;
  border-radius: var(--radius-sm); font-weight: 600;
  white-space: nowrap;
  border: 1px solid var(--glass-border);
}

/* ============================================================
   Controls
   ============================================================ */
.controls {
  display: flex; gap: 8px; padding: 8px 12px;
  border-bottom: 1px solid var(--glass-border);
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
}
.btn {
  flex: 1; padding: 10px 8px;
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  color: var(--text); font-size: 13px; font-weight: 600;
  cursor: pointer; text-align: center;
  transition: all 0.25s ease;
  -webkit-appearance: none;
  font-family: 'Inter', sans-serif;
}
.btn:hover {
  border-color: rgba(56,189,248,0.3);
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}
.btn:active { transform: scale(0.96); }
.btn-primary {
  background: var(--blue); color: #0f172a;
  border-color: var(--blue);
  box-shadow: 0 0 12px rgba(56,189,248,0.3);
}
.btn-primary:hover {
  box-shadow: 0 0 20px rgba(56,189,248,0.5);
}
.btn-record {
  background: var(--red); color: #fff;
  border-color: var(--red);
  box-shadow: 0 0 10px rgba(255,46,46,0.3);
}
.btn-record.recording { animation: pulse 1s infinite; }
.btn:disabled { opacity: 0.35; cursor: not-allowed; }

/* ---- Start button ---- */
.start-btn {
  padding: 12px 24px;
  background: var(--blue); color: #0f172a;
  border: none; border-radius: var(--radius-lg);
  font-size: 15px; font-weight: 700;
  cursor: pointer; transition: all 0.25s ease;
  box-shadow: 0 0 16px rgba(56,189,248,0.3);
  font-family: 'Inter', sans-serif;
}
.start-btn:hover {
  box-shadow: 0 0 24px rgba(56,189,248,0.5);
  transform: translateY(-1px);
}
.start-btn.running {
  background: var(--red);
  box-shadow: 0 0 16px rgba(255,46,46,0.3);
}

/* ============================================================
   Tab Bar
   ============================================================ */
.tab-bar {
  display: flex;
  border-bottom: 1px solid var(--glass-border);
  overflow-x: auto; -webkit-overflow-scrolling: touch;
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
}
.tab {
  flex: none; padding: 10px 14px;
  font-size: 12px; font-weight: 600;
  color: var(--text-dim);
  border-bottom: 2px solid transparent;
  cursor: pointer; white-space: nowrap;
  transition: all 0.25s ease;
  font-family: 'Inter', sans-serif;
}
.tab:hover { color: var(--text); }
.tab.active {
  color: var(--blue);
  border-bottom-color: var(--blue);
  text-shadow: 0 0 8px rgba(56,189,248,0.3);
}

/* ============================================================
   Metrics Panel & Cards
   ============================================================ */
.metrics-panel {
  padding: 8px 12px 120px;
}
.metric-card {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: 12px 14px;
  margin-bottom: 8px;
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
}
.metric-card:hover {
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}
.metric-card.status-good {
  border-left: 3px solid var(--green);
  box-shadow: inset 3px 0 8px -3px rgba(0,255,148,0.15);
}
.metric-card.status-warn {
  border-left: 3px solid var(--yellow);
  box-shadow: inset 3px 0 8px -3px rgba(255,230,0,0.15);
}
.metric-card.status-bad {
  border-left: 3px solid var(--red);
  box-shadow: inset 3px 0 8px -3px rgba(255,46,46,0.15);
}
.metric-card.status-none {
  border-left: 3px solid rgba(255,255,255,0.08);
}

.metric-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 4px;
}
.metric-name {
  font-size: 13px; font-weight: 700;
  font-family: 'Inter', sans-serif;
}
.metric-badge {
  font-size: 10px; padding: 2px 8px;
  border-radius: var(--radius-sm); font-weight: 700;
  border: 1px solid transparent;
  font-family: 'Inter', sans-serif;
}
.badge-good {
  background: rgba(0,255,148,0.12);
  color: var(--green);
  border-color: rgba(0,255,148,0.25);
}
.badge-warn {
  background: rgba(255,230,0,0.12);
  color: var(--yellow);
  border-color: rgba(255,230,0,0.25);
}
.badge-bad {
  background: rgba(255,46,46,0.12);
  color: var(--red);
  border-color: rgba(255,46,46,0.25);
}

.metric-value {
  font-size: 24px; font-weight: 800;
  font-family: 'Roboto Mono', monospace;
  margin: 2px 0;
  letter-spacing: -0.5px;
}
.metric-card.status-good .metric-value {
  text-shadow: 0 0 10px rgba(0,255,148,0.5);
}
.metric-detail {
  font-size: 11px; color: var(--text-dim);
  line-height: 1.5;
}
.metric-ref {
  font-size: 9px; color: var(--purple);
  margin-top: 4px; font-style: italic;
  opacity: 0.8;
}

/* ============================================================
   History Panel
   ============================================================ */
.history-panel { padding: 8px 12px 120px; display: none; }
.snapshot-card {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md); margin-bottom: 10px;
  overflow: hidden;
}
.snapshot-header {
  padding: 8px 12px;
  display: flex; justify-content: space-between; align-items: center;
  border-bottom: 1px solid var(--glass-border);
}
.snapshot-time {
  font-size: 12px; font-weight: 600;
  font-family: 'Roboto Mono', monospace;
}
.snapshot-rula {
  font-size: 11px; font-weight: 700;
  font-family: 'Roboto Mono', monospace;
}
.snapshot-body { padding: 8px 12px; }
.snapshot-metrics {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 4px; font-size: 11px;
}
.snapshot-metric {
  display: flex; justify-content: space-between;
  padding: 2px 0;
}
.snapshot-img {
  width: 100%; aspect-ratio: 4/3;
  object-fit: cover; display: block;
}

/* ============================================================
   Info Panel
   ============================================================ */
.info-panel { padding: 12px; display: none; }
.info-section {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md); padding: 14px;
  margin-bottom: 10px;
}
.info-section h3 {
  font-size: 13px; margin-bottom: 8px;
  color: var(--blue);
  font-family: 'Inter', sans-serif;
}
.info-section p, .info-section li {
  font-size: 11px; color: var(--text-dim);
  line-height: 1.6;
}
.info-section ul { padding-left: 16px; }

/* ============================================================
   No Camera Message
   ============================================================ */
.no-camera {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  height: 100%; color: var(--text-dim);
  font-size: 14px; gap: 8px;
}
.no-camera-icon { font-size: 40px; opacity: 0.3; }

/* ---- Camera video / overlay aliases ---- */
.camera-video {
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%;
  object-fit: cover;
}
.camera-overlay {
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%;
  object-fit: cover;
  pointer-events: none;
}

/* ============================================================
   Camera Select & Smoothing
   ============================================================ */
.camera-select {
  position: absolute; bottom: 8px; left: 8px;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.1);
  color: #fff; font-size: 11px;
  padding: 4px 8px; border-radius: var(--radius-sm);
  z-index: 10; -webkit-appearance: none;
  font-family: 'Inter', sans-serif;
}

.smoothing-indicator {
  position: absolute; bottom: 8px; right: 8px;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: var(--text-dim); font-size: 10px;
  padding: 3px 8px; border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.06);
  z-index: 10;
  font-family: 'Roboto Mono', monospace;
}

/* ============================================================
   S5: Report
   ============================================================ */
.report-content { padding: 12px 12px 120px; }
.report-score-card {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-xl); padding: 28px;
  text-align: center; margin-bottom: 16px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}
.report-score-value {
  font-size: 56px; font-weight: 800;
  font-family: 'Roboto Mono', monospace;
  letter-spacing: -2px;
}
.report-score-label {
  font-size: 13px; color: var(--text-dim); margin-top: 4px;
  font-family: 'Inter', sans-serif;
}
.report-score-sub {
  font-size: 12px; margin-top: 8px;
  padding: 4px 14px; border-radius: 20px;
  display: inline-block; font-weight: 600;
  border: 1px solid var(--glass-border);
}

.report-metric {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg); padding: 14px; margin-bottom: 10px;
}
.report-metric-header {
  display: flex; justify-content: space-between;
  align-items: center; margin-bottom: 8px;
}
.report-metric-name {
  font-size: 14px; font-weight: 700;
  font-family: 'Inter', sans-serif;
}
.report-metric-stats {
  display: grid; grid-template-columns: 1fr 1fr 1fr;
  gap: 8px; margin-bottom: 10px;
}
.report-stat { text-align: center; }
.report-stat-val {
  font-size: 18px; font-weight: 700;
  font-family: 'Roboto Mono', monospace;
}
.report-stat-label {
  font-size: 10px; color: var(--text-dim);
  font-family: 'Inter', sans-serif;
}
.report-chart {
  width: 100%; height: 60px; margin-bottom: 10px;
  border-radius: var(--radius-sm);
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.04);
}
.report-advice {
  font-size: 12px; color: var(--text-dim); line-height: 1.6;
}
.report-advice strong { color: var(--text); }
.report-ref {
  font-size: 10px; color: var(--purple);
  margin-top: 6px; font-style: italic; opacity: 0.8;
}

.report-worst {
  background: rgba(255,46,46,0.08);
  border: 1px solid rgba(255,46,46,0.25);
  border-radius: var(--radius-lg); padding: 14px; margin-bottom: 16px;
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
}
.report-worst h3 {
  font-size: 13px; color: var(--red); margin-bottom: 6px;
  font-family: 'Inter', sans-serif;
}
.report-worst p {
  font-size: 12px; color: var(--text-dim); line-height: 1.5;
}
.report-actions {
  display: flex; gap: 10px; margin-top: 16px; padding-bottom: 20px;
}

/* ============================================================
   Utility: Neon glow for status values
   ============================================================ */
.status-good .metric-value,
.status-good .rula-score { color: var(--green); text-shadow: 0 0 10px rgba(0,255,148,0.5); }
.status-warn .metric-value,
.status-warn .rula-score { color: var(--yellow); text-shadow: 0 0 10px rgba(255,230,0,0.5); }
.status-bad .metric-value,
.status-bad .rula-score { color: var(--red); text-shadow: 0 0 10px rgba(255,46,46,0.5); }
.status-none .metric-value { color: var(--text-dim); }

/* ============================================================
   Scrollbar (webkit)
   ============================================================ */
::-webkit-scrollbar { width: 4px; height: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 2px; }
::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.15); }
</style>
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Noto+Sans+JP:wght@400;500;600;700;800&family=Roboto+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
</head>
<body>

<!-- Loading screen -->
<div class="loading-screen" id="loadingScreen">
  <div class="loading-spinner"></div>
  <div class="loading-text">ViolinPosture ã‚’èµ·å‹•ä¸­...</div>
  <div class="loading-progress" id="loadingProgress">MediaPipe ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™</div>
</div>

<!-- Header -->
<header>
  <h1><span>Violin</span>Posture</h1>
  <div class="view-toggle" id="viewToggle">
    <button class="view-toggle-btn active" data-mode="teacher">ğŸ“‹ ãã‚ã—ã„</button>
    <button class="view-toggle-btn" data-mode="easy">âœ¨ ã‹ã‚“ãŸã‚“</button>
  </div>
  <div class="header-badge">ç ”ç©¶ãƒ™ãƒ¼ã‚¹ v3.0</div>
</header>

<!-- ===== S1: Focus Area Selection ===== -->
<div class="screen active" id="screenSelect">
  <div style="padding:16px 16px 8px;">
    <h2 style="font-size:16px;font-weight:700;">å§¿å‹¢åˆ†æ</h2>
    <p style="font-size:12px;color:var(--text-dim);margin-top:4px;">ã¾ãšå…¨èº«è¨ºæ–­ã§å•é¡Œã‚’ç‰¹å®šã€ã¾ãŸã¯æ°—ã«ãªã‚‹éƒ¨ä½ã‚’ç›´æ¥åˆ†æ</p>
  </div>
  <div class="focus-fullscan" id="btnFullScan">
    <div class="fs-icon">ğŸ”</div>
    <div class="fs-text">
      <div class="fs-label">å…¨èº«ã‚¯ã‚¤ãƒƒã‚¯è¨ºæ–­</div>
      <div class="fs-desc">15ç§’ã§å…¨10æŒ‡æ¨™ã‚’æ¸¬å®šã—ã€ç‰¹ã«æ³¨æ„ãŒå¿…è¦ãªéƒ¨ä½ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ</div>
    </div>
    <div class="fs-arrow">â€º</div>
  </div>
  <div style="padding:4px 16px 0;"><div style="font-size:11px;color:var(--text-dim);text-align:center;margin-bottom:-4px;">â€” ã¾ãŸã¯éƒ¨ä½ã‚’é¸ã‚“ã§è©³ç´°åˆ†æ â€”</div></div>
  <div class="focus-grid" id="focusGrid">
    <!-- Populated by JS -->
  </div>
</div>

<!-- ===== S2: Camera Guide ===== -->
<div class="screen" id="screenGuide">
  <div class="guide-content" id="guideContent">
    <!-- Populated dynamically by JS -->
  </div>
  <div class="guide-btn-row">
    <button class="btn btn-primary" id="btnStartAnalysis" style="width:100%;padding:14px;font-size:15px;">ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã—ã¦åˆ†æé–‹å§‹</button>
    <button class="btn" id="btnBackToSelect" style="width:100%;margin-top:8px;">éƒ¨ä½ã‚’é¸ã³ç›´ã™</button>
  </div>
</div>

<!-- ===== S3: Live Analysis ===== -->
<div class="screen" id="screenLive">
  <div class="camera-section" id="cameraSection">
    <div class="no-camera" id="noCameraMsg">
      <div class="no-camera-icon">&#9898;</div>
      <div>ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...</div>
    </div>
    <video id="video" autoplay muted playsinline webkit-playsinline></video>
    <canvas id="overlay"></canvas>
    <div class="fps-badge" id="fpsBadge" style="display:none;">-- FPS</div>
    <div class="recording-badge" id="recordingBadge">REC</div>
    <select class="camera-select" id="cameraSelect" style="display:none;">
      <option value="user">å‰é¢ã‚«ãƒ¡ãƒ©</option>
      <option value="environment">èƒŒé¢ã‚«ãƒ¡ãƒ©</option>
    </select>
    <div class="smoothing-indicator" id="smoothingInfo" style="display:none;">EMA Î±=0.3</div>
    <!-- Measurement overlay -->
    <div class="measure-overlay" id="measureOverlay" style="display:none;">
      <div class="measure-countdown" id="measureCountdown"></div>
      <div class="measure-timer" id="measureTimer" style="display:none;">00:00</div>
      <div class="measure-progress"><div class="measure-progress-fill" id="measureProgress"></div></div>
    </div>
    <!-- Readiness check overlay -->
    <div class="readiness-overlay" id="readinessOverlay" style="display:none;">
      <div class="readiness-title" id="readinessTitle">ãƒã‚¸ã‚·ãƒ§ãƒ³ç¢ºèªä¸­</div>
      <div class="readiness-checks" id="readinessChecks"></div>
      <div class="readiness-hint" id="readinessHint">å¿…è¦ãªéƒ¨ä½ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„</div>
      <button class="btn-cancel-readiness" id="btnCancelReadiness">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
  </div>

  <div class="rula-bar" id="rulaBar">
    <div class="rula-label">RULAç·åˆ</div>
    <div class="rula-track"><div class="rula-fill" id="rulaFill"></div></div>
    <div class="rula-score" id="rulaScore">--</div>
    <div class="rula-level" id="rulaLevel" style="background:var(--card-border);color:var(--text-dim);">å¾…æ©Ÿä¸­</div>
  </div>

  <div class="controls">
    <button class="btn" id="btnBackFromLive">æˆ»ã‚‹</button>
    <button class="btn btn-primary" id="btnMeasure30">15ç§’æ¸¬å®š</button>
    <button class="btn" id="btnSnapshot">æ’®å½±</button>
    <button class="btn btn-record" id="btnRecord">éŒ²ç”» 5ç§’</button>
  </div>

  <div class="tab-bar">
    <div class="tab active" data-panel="metrics">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ</div>
    <div class="tab" data-panel="history">å±¥æ­´</div>
    <div class="tab" data-panel="info">ç ”ç©¶æ ¹æ‹ </div>
  </div>

  <div class="metrics-panel" id="metricsPanel">
    <!-- Metric cards generated by JS based on selected focus area -->
    <div id="metricCards"></div>
    <!-- Inline report after 15s measurement -->
    <div id="inlineReport" style="display:none;"></div>
  </div>

  <div class="history-panel" id="historyPanel">
    <div id="historyList" style="color:var(--text-dim);font-size:13px;text-align:center;padding:40px 0;">
      ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€ŒéŒ²ç”» 5ç§’ã€ã¾ãŸã¯ã€Œæ’®å½±ã€ã§è¨˜éŒ²ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
    </div>
  </div>

  <div class="info-panel" id="infoPanel">
    <div class="info-section">
      <h3>ã“ã®ã‚¢ãƒ—ãƒªã«ã¤ã„ã¦</h3>
      <p>å­¦è¡“ç ”ç©¶ã«åŸºã¥ããƒã‚¤ã‚ªãƒªãƒ³å¥è€…å°‚ç”¨ã®å§¿å‹¢åˆ†æã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚MediaPipe Pose Landmarkerã«ã‚ˆã‚‹33ç‚¹ã®ãƒœãƒ‡ã‚£ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¤œå‡ºã‚’ç”¨ã„ã€æ¼”å¥é–¢é€£ç­‹éª¨æ ¼éšœå®³(PRMDs)ã®ãƒªã‚¹ã‚¯å› å­ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è©•ä¾¡ã—ã¾ã™ã€‚</p>
    </div>
    <div class="info-section">
      <h3>RULAï¼ˆç°¡æ˜“ä¸Šè‚¢è©•ä¾¡ï¼‰ã‚¹ã‚³ã‚¢ã«ã¤ã„ã¦</h3>
      <p>RULA(Rapid Upper Limb Assessment)ã¯äººé–“å·¥å­¦çš„ãƒªã‚¹ã‚¯ã®å›½éš›æ¨™æº–è©•ä¾¡æ³•ã§ã™ã€‚æœ¬ã‚¢ãƒ—ãƒªã§ã¯å„æŒ‡æ¨™ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’çµ±åˆã—ã€1-7ã®ã‚¹ã‚³ã‚¢ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚</p>
      <ul>
        <li>1-2: è¨±å®¹ç¯„å›² â€” è‰¯å¥½ãªå§¿å‹¢</li>
        <li>3-4: è¦è¦³å¯Ÿ â€” æ”¹å–„ã‚’æ¤œè¨</li>
        <li>5-6: è¦æ”¹å–„ â€” æ—©æœŸã«å§¿å‹¢ä¿®æ­£ã‚’</li>
        <li>7: è¦å³æ™‚å¯¾å¿œ â€” ç›´ã¡ã«å§¿å‹¢ã‚’ä¿®æ­£</li>
      </ul>
    </div>
    <div class="info-section">
      <h3>ä¸»è¦å‚è€ƒæ–‡çŒ®</h3>
      <ul>
        <li>Kok LM et al. (2013) â€” ãƒã‚¤ã‚ªãƒªãƒ‹ã‚¹ãƒˆã®ç­‹éª¨æ ¼éšœå®³ç³»çµ±ãƒ¬ãƒ“ãƒ¥ãƒ¼ (PMC3718408)</li>
        <li>Mann S et al. (2023) â€” äººé–“å·¥å­¦çš„é¡å½“ã¦ã®ç”Ÿä½“åŠ›å­¦ç ”ç©¶</li>
        <li>Schoonderwaldt E et al. (2015) â€” ãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ã®ç”Ÿä½“åŠ›å­¦ (PMC4636401)</li>
        <li>Tondini et al. (2022) â€” å³è‚©ç”²ä¸Šè…•é–¢ç¯€åŠ›ã®åˆ†æ (PMC8842773)</li>
        <li>Woldendorp KH et al. (2021) â€” æ¼”å¥é–¢é€£é‹å‹•éšœå®³ã®ç¥çµŒåŠ›å­¦ãƒ¬ãƒ“ãƒ¥ãƒ¼ (PMC7582398)</li>
        <li>Moraes GFS &amp; Papini AL (2012) â€” ãƒã‚¤ã‚ªãƒªãƒ‹ã‚¹ãƒˆã®è„ŠæŸ±å½æ›²ã¨ä½“å¹¹éå¯¾ç§°</li>
      </ul>
    </div>
    <div class="info-section">
      <h3>ä½¿ã„æ–¹ã®ã‚³ãƒ„</h3>
      <ul>
        <li>æ˜ã‚‹ã„å ´æ‰€ã§ä½¿ç”¨ã—ã¦ãã ã•ã„</li>
        <li>ã‚«ãƒ¡ãƒ©ã‹ã‚‰1.5-2mé›¢ã‚Œã‚‹ã¨ç²¾åº¦ãŒå‘ä¸Šã—ã¾ã™</li>
        <li>ä¸ŠåŠèº«å…¨ä½“ï¼ˆé ­ã€œè…°ï¼‰ãŒæ˜ ã‚‹ä½ç½®ãŒç†æƒ³çš„ã§ã™</li>
        <li>èƒŒé¢ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ã¦ã‚‚ã‚‰ã†ã¨ã‚ˆã‚Šæ­£ç¢ºã§ã™</li>
      </ul>
    </div>
  </div>
</div>

<!-- ===== S5: Detailed Report ===== -->
<div class="screen" id="screenReport">
  <div class="report-content" id="reportContent">
    <!-- Generated dynamically by JS -->
  </div>
</div>

<!-- PiP Camera (shown when scrolling away from camera in live mode) -->
<div class="camera-pip" id="cameraPip">
  <video id="videoPip" autoplay muted playsinline webkit-playsinline></video>
  <canvas id="overlayPip"></canvas>
</div>

<script type="module">
import {
  PoseLandmarker,
  FilesetResolver,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/vision_bundle.mjs";

// =============================================================================
// FOCUS AREAS DATA
// =============================================================================
const FOCUS_AREAS = {
  head: {
    label: 'é ­éƒ¨ãƒ»é¦–', icon: 'ğŸ¯',
    desc: 'CVAï¼ˆå‰æ–¹é ­ä½ï¼‰ãƒ»é ­éƒ¨å‚¾æ–œãƒ»é ­éƒ¨å›æ—‹',
    metrics: ['cva', 'headTilt', 'headRot'],
    skeletonHighlight: [0,1,2,3,4,5,6,7,8,9,10,11,12],
    cameraGuide: {
      angle: 'æ­£é¢', distance: '1.5ã€œ2m',
      visibleParts: 'é ­ã‹ã‚‰è‚©ã¾ã§ç”»é¢ã«åã¾ã‚‹ä½ç½®',
      tips: ['é«ªãŒè€³ã«ã‹ã‹ã‚‹å ´åˆã¯è€³ã«ã‹ã‘ã¦ãã ã•ã„','é¡å½“ã¦ã«é¡ã‚’ä¹—ã›ãŸæ¼”å¥å§¿å‹¢ã§æ’®å½±','è€³ã¨è‚©ãŒã¯ã£ãã‚Šè¦‹ãˆã‚‹ã“ã¨ãŒé‡è¦','èƒŒé¢ã‚«ãƒ¡ãƒ©ã§ä»–ã®äººã«æ’®ã£ã¦ã‚‚ã‚‰ã†ã¨ã‚ˆã‚Šæ­£ç¢º'],
      svgAngle: 'front'
    },
    deepAnalysis: {
      overview: 'ãƒã‚¤ã‚ªãƒªãƒ³æ¼”å¥ã§ã¯æ¥½å™¨ã‚’å·¦é¡ã§æ”¯ãˆã‚‹ãŸã‚ã€é ­é ¸éƒ¨ã«ç‰¹æœ‰ã®è² è·ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç”Ÿã˜ã¾ã™ã€‚å‰æ–¹é ­ä½ï¼ˆForward Head Postureï¼‰ã¨å·¦å´æ–¹å‚¾æ–œã®çµ„ã¿åˆã‚ã›ã¯ã€åƒ§å¸½ç­‹ãƒ»èƒ¸é–ä¹³çªç­‹ã¸ã®æ…¢æ€§çš„ãªéè² è·ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚',
      easyOverview: 'ãƒã‚¤ã‚ªãƒªãƒ³ã‚’å¼¾ãã¨ãã€é ­ã®ä½ç½®ã¯ã¨ã¦ã‚‚å¤§åˆ‡ã ã‚ˆã€‚é ­ãŒå‰ã«å‡ºã™ããŸã‚Šã€å‚¾ãã™ãã‚‹ã¨ã€é¦–ãŒç–²ã‚Œã‚„ã™ããªã‚‹ã‚“ã ã€‚',
      metrics: {
        cva: {
          name: 'é ­é ¸è§’ (CVA)',
          goodAdvice: 'è‰¯å¥½ãªé ­é ¸ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã§ã™ã€‚ã“ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ç¶­æŒã™ã‚‹ã“ã¨ã§ã€é ¸æ¤ã¸ã®è² è·ã‚’æœ€å°é™ã«æŠ‘ãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'è»½åº¦ã®å‰æ–¹é ­ä½ãŒè¦‹ã‚‰ã‚Œã¾ã™ã€‚é¡ã‚’å¼•ãæ„è­˜ï¼ˆãƒãƒ³ã‚¿ãƒƒã‚¯ï¼‰ã‚’æŒã¡ã¾ã—ã‚‡ã†ã€‚è‚©å½“ã¦ã®é«˜ã•èª¿æ•´ã‚‚æ¤œè¨ã—ã¦ãã ã•ã„ã€‚',
          badAdvice: 'é¡•è‘—ãªå‰æ–¹é ­ä½ã§ã™ã€‚æ¼”å¥ä¸­ã«é ­ãŒå‰ã«çªãå‡ºã¦ã„ã¾ã™ã€‚è‚©å½“ã¦ãƒ»é¡å½“ã¦ã®ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°è¦‹ç›´ã—ãŒå¿…è¦ã§ã™ã€‚é ¸æ¤ç—‡ã®ãƒªã‚¹ã‚¯ãŒä¸Šæ˜‡ã—ã¾ã™ã€‚',
          tips: ['ãƒãƒ³ã‚¿ãƒƒã‚¯ï¼ˆé¡å¼•ãï¼‰ã‚¨ã‚¯ã‚µã‚µã‚¤ã‚ºã‚’æ—¥å¸¸çš„ã«å®Ÿè·µ','è‚©å½“ã¦ã®é«˜ã•ã‚’ä¸Šã’ã¦é¡å½“ã¦ã¸ã®åœ§è¿«ã‚’è»½æ¸›','æ¼”å¥ä¸­ã«å®šæœŸçš„ã«é¦–ã®ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ','é¡ã‚’è¦‹ãªãŒã‚‰ç·´ç¿’ã—ã¦é ­éƒ¨ä½ç½®ã‚’ç¢ºèª'],
          ref: 'Yip et al. (2008) PMC6296804 â€” CVA>53Â°ãŒæ­£å¸¸ã€<48Â°ã§å‰æ–¹é ­ä½ã¨åˆ¤å®šã€‚',
          easyGoodAdvice: 'é ­ã®ä½ç½®ãƒãƒƒãƒãƒªï¼ãã®ã¾ã¾ç¶šã‘ã‚ˆã†ã€‚',
          easyWarnAdvice: 'é ­ãŒå°‘ã—å‰ã«å‡ºã¦ã„ã‚‹ã‚ˆã€‚é¡ã‚’å¼•ã„ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'é ­ãŒã ã„ã¶å‰ã«å‡ºã¦ã„ã‚‹ã‚ˆã€‚è‚©å½“ã¦ã‚„é¡å½“ã¦ã‚’èª¿æ•´ã—ã¦ã¿ã‚ˆã†ã€‚',
          easyTips: ['é¡ã‚’å¼•ãç·´ç¿’ã‚’ã—ã‚ˆã†','è‚©å½“ã¦ã®é«˜ã•ã‚’èª¿æ•´ã—ã¦ã¿ã‚ˆã†','ã¨ãã©ãé¦–ã®ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆã—ã‚ˆã†','é¡ã‚’è¦‹ãªãŒã‚‰ç·´ç¿’ã—ã‚ˆã†']
        },
        headTilt: {
          name: 'é ­éƒ¨å´æ–¹å‚¾æ–œ',
          goodAdvice: 'é ­éƒ¨ãŒå®‰å®šã—ãŸä¸­ç«‹ä½ã‚’ä¿ã£ã¦ã„ã¾ã™ã€‚å·¦å³ãƒãƒ©ãƒ³ã‚¹ã®è‰¯ã„æ¥½å™¨ä¿æŒãŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'è»½åº¦ã®å´æ–¹å‚¾æ–œãŒã‚ã‚Šã¾ã™ã€‚æ¥½å™¨ã‚’é¡ã§ã€ŒæŒŸã¿ã™ããªã„ã€æ„è­˜ã‚’æŒã¡ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'éåº¦ãªé ­éƒ¨å‚¾æ–œã§ã™ã€‚é¦–ã®ç­‹è‚‰ã«ä¸å‡è¡¡ãªè² è·ãŒã‹ã‹ã£ã¦ã„ã¾ã™ã€‚é¡å½“ã¦å½¢çŠ¶ã®è¦‹ç›´ã—ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚',
          tips: ['é¡å½“ã¦ã®é«˜ã•ãƒ»è§’åº¦ã‚’å†èª¿æ•´','æ¼”å¥ä¸­ã«é¦–ã‚’ã€Œé ã‘ã‚‹ã€ã®ã§ã¯ãªãã€Œæ·»ãˆã‚‹ã€æ„è­˜','ä¼‘æ†©æ™‚ã«é¦–ã®å´å±ˆã‚¹ãƒˆãƒ¬ãƒƒãƒ','æ¥½å™¨ã®é‡ã•ã¯é–éª¨ã§æ”¯ãˆã€é¡ã¯æ–¹å‘åˆ¶å¾¡ã«ä½¿ã†'],
          ref: 'Mann S et al. (2023) â€” é ­éƒ¨å‚¾æ–œ10Â°ä»¥ä¸Šã§é ¸éƒ¨ç­‹ç¾¤ã®ç–²åŠ´åŠ é€Ÿã€‚',
          easyGoodAdvice: 'é ­ã®å‚¾ãã€ã„ã„æ„Ÿã˜ï¼',
          easyWarnAdvice: 'å°‘ã—é ­ãŒå‚¾ã„ã¦ã„ã‚‹ã‚ˆã€‚æ¥½å™¨ã‚’æŒŸã¿ã™ããªã„ã‚ˆã†ã«ã—ã‚ˆã†ã€‚',
          easyBadAdvice: 'é ­ãŒå‚¾ãã™ãï¼é¡å½“ã¦ã®å½¢ã‚’è¦‹ç›´ã—ã¦ã¿ã‚ˆã†ã€‚',
          easyTips: ['é¡å½“ã¦ã®é«˜ã•ã‚„è§’åº¦ã‚’èª¿æ•´ã—ã‚ˆã†','é¦–ã‚’ã€Œé ã‘ã‚‹ã€ã®ã§ã¯ãªãã€Œæ·»ãˆã‚‹ã€ã‚¤ãƒ¡ãƒ¼ã‚¸','ä¼‘æ†©ä¸­ã«é¦–ã®ã‚¹ãƒˆãƒ¬ãƒƒãƒã‚’ã—ã‚ˆã†','æ¥½å™¨ã¯é–éª¨ã§æ”¯ãˆã‚ˆã†']
        },
        headRot: {
          name: 'é ­éƒ¨å›æ—‹æ¨å®š',
          goodAdvice: 'é©åº¦ãªå›æ—‹ç¯„å›²ã§ã™ã€‚è¦–ç·šã¨æ¥½å™¨ã®ä½ç½®é–¢ä¿‚ãŒè‰¯å¥½ã§ã™ã€‚',
          warnAdvice: 'å›æ—‹ãŒã‚„ã‚„å¤§ãã‚ã§ã™ã€‚è‚©å½“ã¦ä½ç½®ã‚’ä½“ã®ä¸­å¿ƒå¯„ã‚Šã«ãšã‚‰ã™ã¨æ”¹å–„ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚',
          badAdvice: 'éåº¦ãªé ­éƒ¨å›æ—‹ã§ã™ã€‚é ¸æ¤ã®å›æ—‹åˆ¶é™åŸŸã«è¿‘ã¥ã„ã¦ãŠã‚Šã€æ¤é–“æ¿ã¸ã®åœ§è¿«ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚',
          tips: ['æ¥½å™¨ã®ä½ç½®ã‚’ä½“ã®ä¸­å¿ƒå¯„ã‚Šã«èª¿æ•´','è­œé¢å°ã®ä½ç½®ã‚’æ­£é¢ã‚ˆã‚Šã‚„ã‚„å·¦ã«','é¡ã‚’å‰æ–¹ã«ç½®ã„ã¦å›æ—‹é‡ã‚’è‡ªè¦š','æ¼”å¥å‰ã«é ¸æ¤ãƒ¢ãƒ“ãƒªãƒ†ã‚£ã‚¨ã‚¯ã‚µã‚µã‚¤ã‚º'],
          ref: 'Mann S et al. (2023) â€” é ­éƒ¨å›æ—‹30Â°è¶…ã§ç—‡çŠ¶ç™ºç¾ãƒªã‚¹ã‚¯ä¸Šæ˜‡ã€‚',
          easyGoodAdvice: 'é¡”ã®å‘ãã€ã¡ã‚‡ã†ã©ã„ã„ã‚ˆï¼',
          easyWarnAdvice: 'é¡”ãŒå›ã‚Šã™ãã‹ã‚‚ã€‚è‚©å½“ã¦ã®ä½ç½®ã‚’èª¿æ•´ã—ã¦ã¿ã¦ã€‚',
          easyBadAdvice: 'é¡”ã®å›ã—ã™ãã«æ³¨æ„ï¼æ¥½å™¨ã®ä½ç½®ã‚’è¦‹ç›´ãã†ã€‚',
          easyTips: ['æ¥½å™¨ã‚’å°‘ã—ä½“ã®ä¸­å¿ƒã‚ˆã‚Šã«å‹•ã‹ã—ã¦ã¿ã‚ˆã†','è­œé¢å°ã¯å°‘ã—å·¦ã«ç½®ã„ã¦ã¿ã‚ˆã†','é¡ã§è‡ªåˆ†ã®é¡”ã®å‘ãã‚’ç¢ºèªã—ã‚ˆã†','ç·´ç¿’å‰ã«é¦–ã®ã‚¹ãƒˆãƒ¬ãƒƒãƒã‚’ã—ã‚ˆã†']
        }
      }
    }
  },
  shoulders: {
    label: 'è‚©', icon: 'ğŸ’ª',
    desc: 'å·¦è‚©æŒ™ä¸Šãƒ»è‚©å·¦å³éå¯¾ç§°',
    metrics: ['lShoulderElev', 'shoulderSym'],
    skeletonHighlight: [11,12,13,14,23,24],
    cameraGuide: {
      angle: 'æ­£é¢', distance: '1.5ã€œ2m',
      visibleParts: 'ä¸¡è‚©ãƒ»ä¸Šè…•ãŒå®Œå…¨ã«è¦‹ãˆã‚‹ä½ç½®',
      tips: ['ä¸¡è‚©ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«','èƒŒæ™¯ã¯ã‚·ãƒ³ãƒ—ãƒ«ãªå£ãŒç†æƒ³çš„','æ¼”å¥ä¸­ã®è‡ªç„¶ãªå§¿å‹¢ã§æ’®å½±','ã‚«ãƒ¡ãƒ©ã¯èƒ¸ã®é«˜ã•ã«è¨­ç½®'],
      svgAngle: 'front'
    },
    deepAnalysis: {
      overview: 'ãƒã‚¤ã‚ªãƒªãƒ³æ¼”å¥æ™‚ã®è‚©ã®å•é¡Œã¯æœ€ã‚‚ä¸€èˆ¬çš„ãªæ„è¨´ã§ã™ã€‚å·¦è‚©ã®æŒ™ä¸Šã¨è‚©ã®å·¦å³éå¯¾ç§°ã¯ã€åƒ§å¸½ç­‹ä¸Šéƒ¨ç·šç¶­ã®éç·Šå¼µã‚’å¼•ãèµ·ã“ã—ã€è‚©ã“ã‚Šãƒ»é ¸éƒ¨ç—›ã®ä¸»è¦å› ã¨ãªã‚Šã¾ã™ã€‚',
      easyOverview: 'è‚©ã®åŠ›ã‚’æŠœãã®ãŒå¤§åˆ‡ï¼å·¦è‚©ãŒä¸ŠãŒã‚Šã™ããŸã‚Šã€å·¦å³ã®ãƒãƒ©ãƒ³ã‚¹ãŒå´©ã‚Œã‚‹ã¨ã€è‚©ã“ã‚Šã®åŸå› ã«ãªã‚‹ã‚ˆã€‚',
      metrics: {
        lShoulderElev: {
          name: 'å·¦è‚©æŒ™ä¸Š',
          goodAdvice: 'å·¦è‚©ãŒé©åˆ‡ãªé«˜ã•ã«ç¶­æŒã•ã‚Œã¦ã„ã¾ã™ã€‚æ¥½å™¨ã‚’è‚©ã¨é–éª¨ã§è‡ªç„¶ã«æ”¯æŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'å·¦è‚©ãŒã‚„ã‚„ä¸ŠãŒã£ã¦ã„ã¾ã™ã€‚åƒ§å¸½ç­‹ä¸Šéƒ¨ã®ç·Šå¼µã‚’æ„è­˜çš„ã«ãƒªãƒªãƒ¼ã‚¹ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'å·¦è‚©ãŒé¡•è‘—ã«æŒ™ä¸Šã—ã¦ã„ã¾ã™ã€‚åƒ§å¸½ç­‹ãƒ»è‚©ç”²æŒ™ç­‹ã¸ã®æ…¢æ€§çš„ãªéè² è·çŠ¶æ…‹ã§ã™ã€‚è‚©å½“ã¦ã®å†èª¿æ•´ãŒæœ€å„ªå…ˆã§ã™ã€‚',
          tips: ['è‚©å½“ã¦ã®é«˜ã•ã‚’ä¸Šã’ã¦è‚©ã®æŒ™ä¸Šã‚’ä¸è¦ã«ã™ã‚‹','æ¼”å¥å‰ã«è‚©ã®ä¸Šã’ä¸‹ã’ã§è„±åŠ›ã‚’ç¢ºèª','é•·ã„ãƒ•ãƒ¬ãƒ¼ã‚ºã®åŒºåˆ‡ã‚Šã§æ„è­˜çš„ã«è‚©ã‚’ä¸‹ã‚ã™','é–éª¨ã®å­˜åœ¨ã‚’æ„è­˜ã—ã¦æ¥½å™¨ã‚’è¼‰ã›ã‚‹'],
          ref: 'Kok LM et al. (2013) PMC3718408 â€” ãƒã‚¤ã‚ªãƒªãƒ‹ã‚¹ãƒˆã®62-93%ãŒç­‹éª¨æ ¼ç—‡çŠ¶ã‚’å ±å‘Šã€‚',
          easyGoodAdvice: 'å·¦è‚©ã®é«˜ã•ã€ãƒãƒƒãƒãƒªï¼åŠ›ãŒæŠœã‘ã¦ã‚‹ã­ã€‚',
          easyWarnAdvice: 'å·¦è‚©ãŒå°‘ã—ä¸ŠãŒã£ã¦ã„ã‚‹ã‚ˆã€‚åŠ›ã‚’æŠœã„ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'å·¦è‚©ãŒä¸ŠãŒã‚Šã™ãï¼è‚©å½“ã¦ã‚’èª¿æ•´ã—ã¦ã€è‚©ã®åŠ›ã‚’æŠœã“ã†ã€‚',
          easyTips: ['è‚©å½“ã¦ã®é«˜ã•ã‚’ä¸Šã’ã¦ã¿ã‚ˆã†','ç·´ç¿’å‰ã«è‚©ã‚’ä¸Šã’ä¸‹ã’ã—ã¦åŠ›ã‚’æŠœã“ã†','ãƒ•ãƒ¬ãƒ¼ã‚ºã®åˆ‡ã‚Œç›®ã§è‚©ã‚’ä¸‹ã‚ãã†','é–éª¨ã®ä¸Šã«æ¥½å™¨ã‚’ã®ã›ã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸']
        },
        shoulderSym: {
          name: 'è‚©é«˜å·¦å³éå¯¾ç§°',
          goodAdvice: 'è‚©ã®å·¦å³ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯å¥½ã§ã™ã€‚ä½“å¹¹ã®å®‰å®šã—ãŸæ”¯æŒåŸºç›¤ãŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'è‚©ã®å·¦å³å·®ãŒã‚„ã‚„å¤§ãã„ã§ã™ã€‚ä½“é‡ã®å·¦å³å‡ç­‰é…åˆ†ã‚’æ„è­˜ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'é¡•è‘—ãªè‚©ã®å·¦å³éå¯¾ç§°ã§ã™ã€‚è„ŠæŸ±å´å¼¯ã®ãƒªã‚¹ã‚¯ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚',
          tips: ['ä¸¡è¶³å‡ç­‰è·é‡ã‚’æ„è­˜','æ¼”å¥å¾Œã«ä¸¡è‚©ã‚’å›ã™å¯¾ç§°çš„ãªã‚¹ãƒˆãƒ¬ãƒƒãƒ','è‚©å½“ã¦é«˜ã•ã®å¾®èª¿æ•´ã§å·¦å³å·®ã‚’è»½æ¸›','ä½“å¹¹ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã§å®‰å®šæ€§å‘ä¸Š'],
          ref: 'Moraes GFS & Papini AL (2012) â€” è„ŠæŸ±éå¯¾ç§°ã¨è‚©é«˜å·®ã®ç›¸é–¢ã€‚',
          easyGoodAdvice: 'è‚©ã®å·¦å³ãƒãƒ©ãƒ³ã‚¹ã„ã„ã­ï¼',
          easyWarnAdvice: 'è‚©ã®å·¦å³å·®ãŒå°‘ã—ã‚ã‚‹ã‚ˆã€‚ä¸¡è¶³ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãç«‹ã£ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'è‚©ã®å·¦å³å·®ãŒå¤§ãã„ã‚ˆã€‚å§¿å‹¢å…¨ä½“ã‚’è¦‹ç›´ã—ã¦ã¿ã‚ˆã†ã€‚',
          easyTips: ['ä¸¡è¶³ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãç«‹ã¨ã†','ç·´ç¿’å¾Œã«ä¸¡è‚©ã‚’å›ã™ã‚¹ãƒˆãƒ¬ãƒƒãƒ','è‚©å½“ã¦ã®é«˜ã•ã‚’å°‘ã—èª¿æ•´','ä½“å¹¹ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãŒãŠã™ã™ã‚']
        }
      }
    }
  },
  'bow-arm': {
    label: 'å¼“è…•ï¼ˆå³è…•ï¼‰', icon: 'ğŸ»',
    desc: 'å³è‚˜å¤–è»¢è§’åº¦',
    metrics: ['rElbowAbd'],
    skeletonHighlight: [12,14,16,18,20,22],
    cameraGuide: {
      angle: 'æ­£é¢', distance: '2ã€œ2.5m',
      visibleParts: 'ä¸¡è…•å…¨ä½“ãŒè¦‹ãˆã‚‹ä½ç½®',
      tips: ['å¼“ã‚’æŒã£ãŸæ¼”å¥å§¿å‹¢ã§æ’®å½±','å„å¼¦ã§ã®é‹å¼“ã‚’æ¯”è¼ƒã™ã‚‹ã¨åŠ¹æœçš„','ã§ãã‚‹ã ã‘å…¨å¼“ã§å¼¾ã„ã¦ã„ã‚‹çŠ¶æ…‹ã‚’æ¸¬å®š','ã‚«ãƒ¡ãƒ©ã¯èƒ¸ã®é«˜ã•ã«è¨­ç½®'],
      svgAngle: 'front'
    },
    deepAnalysis: {
      overview: 'å¼“è…•ï¼ˆå³è…•ï¼‰ã®å‹•ãã¯éŸ³è‰²ã¨ç›´çµã—ã¾ã™ã€‚éåº¦ãªè‚˜ã®å¤–è»¢ã¯ä¸‰è§’ç­‹ãƒ»æ£˜ä¸Šç­‹ã¸ã®è² è·ã‚’å¢—å¤§ã•ã›ã€ã‚¤ãƒ³ãƒ”ãƒ³ã‚¸ãƒ¡ãƒ³ãƒˆç—‡å€™ç¾¤ã®ãƒªã‚¹ã‚¯ã‚’é«˜ã‚ã¾ã™ã€‚',
      easyOverview: 'å¼“ã‚’æŒã¤å³è…•ã®ä½¿ã„æ–¹ãŒéŸ³è‰²ã«å¤§ããå½±éŸ¿ã™ã‚‹ã‚ˆã€‚è‚˜ãŒä¸ŠãŒã‚Šã™ããªã„ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ã‚ˆã†ã€‚',
      metrics: {
        rElbowAbd: {
          name: 'å³è‚˜å¤–è»¢è§’åº¦',
          goodAdvice: 'å¼“è…•ã®å¤–è»¢è§’åº¦ãŒé©åˆ‡ãªç¯„å›²ã§ã™ã€‚åŠ¹ç‡çš„ãªé‹å¼“ãŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'è‚˜ãŒã‚„ã‚„é«˜ã‚ã§ã™ã€‚æ„è­˜çš„ã«è‚˜ã‚’ä¸‹ã’ã€å‰è…•ã®å›æ—‹ã§å¼“ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'è‚˜ã®å¤–è»¢ãŒéå¤§ã§ã™ã€‚ã‚¤ãƒ³ãƒ”ãƒ³ã‚¸ãƒ¡ãƒ³ãƒˆç—‡å€™ç¾¤ã®ãƒªã‚¹ã‚¯ãŒé«˜ã„çŠ¶æ…‹ã§ã™ã€‚é‹å¼“ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã®è¦‹ç›´ã—ãŒå¿…è¦ã§ã™ã€‚',
          tips: ['è‚˜ã¯ã€Œã¶ã‚‰ä¸‹ãŒã‚‹ã€æ„Ÿè¦šã‚’ä¿ã¤','Gç·šã§ã‚‚è‚˜ã‚’ä¸Šã’ã™ããªã„ â€” å‰è…•ã®å›å†…ã§å¯¾å¿œ','é¡ã§å³è…•ã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚’ç¢ºèª','ä¸Šè…•ã¯ä½“å´ã«è¿‘ãä¿ã¡ã¤ã¤å‰è…•ã§æ“ä½œ'],
          ref: 'Berque P et al. (2005) â€” 45Â°ä»¥ä¸‹ãŒç†æƒ³ã€60Â°è¶…ã§è‚©é–¢ç¯€è² è·æ€¥å¢—ã€‚',
          easyGoodAdvice: 'å¼“ã®æ‰‹ã®è‚˜ã®é«˜ã•ã€ã„ã„æ„Ÿã˜ï¼',
          easyWarnAdvice: 'è‚˜ãŒå°‘ã—é«˜ã‚ã ã‚ˆã€‚å°‘ã—ä¸‹ã’ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'è‚˜ãŒä¸ŠãŒã‚Šã™ãï¼è‚˜ã‚’ä¸‹ã’ã¦ã€æ‰‹é¦–ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã‚ˆã†ã€‚',
          easyTips: ['è‚˜ã¯ã€Œã¶ã‚‰ã•ãŒã‚‹ã€ã‚ˆã†ãªã‚¤ãƒ¡ãƒ¼ã‚¸','Gç·šã§ã‚‚è‚˜ã‚’ä¸Šã’ã™ããªã„ã§ã­','é¡ã§å³è…•ã®å½¢ã‚’ç¢ºèªã—ã‚ˆã†','ä¸Šè…•ã¯ä½“ã®è¿‘ãã«ã‚­ãƒ¼ãƒ—']
        }
      }
    }
  },
  'finger-arm': {
    label: 'æŒ‡æ¿è…•ï¼ˆå·¦è…•ï¼‰', icon: 'âœ‹',
    desc: 'å·¦è‚˜è§’åº¦ãƒ»å·¦æ‰‹é¦–åä½',
    metrics: ['lElbowAngle', 'lWristDev'],
    skeletonHighlight: [11,13,15,17,19,21],
    cameraGuide: {
      angle: 'æ­£é¢', distance: '1.5ã€œ2m',
      visibleParts: 'å·¦è…•å…¨ä½“ï¼ˆè‚©ã€œæŒ‡å…ˆï¼‰ãŒè¦‹ãˆã‚‹ä½ç½®',
      tips: ['æ¥½å™¨ã‚’æ§‹ãˆãŸçŠ¶æ…‹ã§æ’®å½±','ãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ä¸­ã‚‚æ¸¬å®šã™ã‚‹ã¨æœ‰ç”¨','æŒ‡ãŒæŒ‡æ¿ä¸Šã«ã‚ã‚‹çŠ¶æ…‹ãŒãƒ™ã‚¹ãƒˆ','æ‰‹é¦–ãŒéš ã‚Œãªã„ã‚ˆã†è§’åº¦ã«æ³¨æ„'],
      svgAngle: 'front'
    },
    deepAnalysis: {
      overview: 'å·¦è…•ã¯ç²¾å¯†ãªæŒ‡ã®é‹å‹•ã¨æ¥½å™¨æ”¯æŒã‚’åŒæ™‚ã«æ‹…ã„ã¾ã™ã€‚è‚˜ã®è§’åº¦ã¨æ‰‹é¦–ã®ç›´ç·šæ€§ã¯ã€é‹æŒ‡ã®åŠ¹ç‡æ€§ã¨è…±é˜ç‚ãƒ»æ‰‹æ ¹ç®¡ç—‡å€™ç¾¤ã®äºˆé˜²ã«ç›´çµã—ã¾ã™ã€‚',
      easyOverview: 'æŠ¼ã•ãˆã‚‹æ‰‹ï¼ˆå·¦æ‰‹ï¼‰ã®è‚˜ã¨æ‰‹é¦–ã®è§’åº¦ãŒå¤§åˆ‡ã ã‚ˆã€‚æ‰‹é¦–ã‚’ã¾ã£ã™ãã«ã™ã‚‹ã¨æŒ‡ãŒå‹•ãã‚„ã™ããªã‚‹ã‚“ã ã€‚',
      metrics: {
        lElbowAngle: {
          name: 'å·¦è‚˜è§’åº¦',
          goodAdvice: 'è‚˜ã®è§’åº¦ãŒç†æƒ³çš„ãªç¯„å›²ã§ã™ã€‚åŠ¹ç‡çš„ãªãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ãŒå¯èƒ½ãªçŠ¶æ…‹ã§ã™ã€‚',
          warnAdvice: 'è‚˜è§’åº¦ãŒåŸºæº–ç¯„å›²ã‹ã‚‰ã‚„ã‚„å¤–ã‚Œã¦ã„ã¾ã™ã€‚ãƒã‚¸ã‚·ãƒ§ãƒ³å¤‰æ›´æ™‚ã®è‚˜ã®å…ˆå°ã‚’æ„è­˜ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'è‚˜è§’åº¦ãŒæ¨å¥¨ç¯„å›²ã‚’å¤§ããé€¸è„±ã—ã¦ã„ã¾ã™ã€‚ä¸Šè…•äºŒé ­ç­‹ã®éç·Šå¼µãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚',
          tips: ['ãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ã¯ã€Œè‚˜å…ˆå°ã€ã§è¡Œã†','ç¬¬1ãƒã‚¸ã‚·ãƒ§ãƒ³ã§ã®è‡ªç„¶ãªè‚˜è§’åº¦ã‚’é¡ã§ç¢ºèª','é«˜ãƒã‚¸ã‚·ãƒ§ãƒ³ã§ã¯è‚˜ã‚’ä½“ã®ä¸‹ã«é€ã‚Šè¾¼ã‚€','è‚˜ã®ä½ç½®ãŒãƒãƒƒã‚¯ã®ä¸‹ã«ãã‚‹ã“ã¨ã‚’æ„è­˜'],
          ref: 'Schoonderwaldt E et al. (2015) PMC4636401 â€” è‚˜è§’50-80Â°ãŒæ©Ÿèƒ½çš„æœ€é©ç¯„å›²ã€‚',
          easyGoodAdvice: 'è‚˜ã®è§’åº¦ã€ã„ã„æ„Ÿã˜ï¼',
          easyWarnAdvice: 'è‚˜ã®è§’åº¦ãŒå°‘ã—ãšã‚Œã¦ã„ã‚‹ã‚ˆã€‚ãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ã®ã¨ãã€è‚˜ã‹ã‚‰å‹•ã‹ã—ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'è‚˜ã®è§’åº¦ãŒã ã„ã¶ãšã‚Œã¦ã„ã‚‹ã‚ˆã€‚å…ˆç”Ÿã¨ä¸€ç·’ã«è¦‹ç›´ã—ã¦ã¿ã‚ˆã†ã€‚',
          easyTips: ['ãƒã‚¸ã‚·ãƒ§ãƒ³ç§»å‹•ã¯ã€Œè‚˜ã‹ã‚‰ã€å‹•ã‹ãã†','é¡ã§è‡ªç„¶ãªè‚˜ã®è§’åº¦ã‚’ç¢ºèª','é«˜ã„ãƒã‚¸ã‚·ãƒ§ãƒ³ã§ã¯è‚˜ã‚’ä½“ã®ä¸‹ã«é€ã‚Šè¾¼ã‚‚ã†','è‚˜ãŒãƒãƒƒã‚¯ã®ä¸‹ã«ãã‚‹ã‚ˆã†ã«']
        },
        lWristDev: {
          name: 'å·¦æ‰‹é¦–åä½',
          goodAdvice: 'æ‰‹é¦–ãŒã»ã¼ç›´ç·šçš„ã«ä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚è…±ã¸ã®è² è·ãŒæœ€å°é™ã®ç†æƒ³çš„ãªçŠ¶æ…‹ã§ã™ã€‚',
          warnAdvice: 'æ‰‹é¦–ã«ã‚„ã‚„åä½ãŒã‚ã‚Šã¾ã™ã€‚å‰è…•-æ‰‹é¦–-æŒ‡ã®ãƒ©ã‚¤ãƒ³ã‚’æ„è­˜ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'æ‰‹é¦–ã®åä½ãŒå¤§ãã„ã§ã™ã€‚è…±é˜ç‚ãƒ»æ‰‹æ ¹ç®¡ç—‡å€™ç¾¤ã®ãƒªã‚¹ã‚¯ãŒé«˜ã„çŠ¶æ…‹ã§ã™ã€‚',
          tips: ['æ‰‹é¦–ã‚’ã€ŒæŠ˜ã‚‰ãªã„ã€â€” å‰è…•ã®å»¶é•·ç·šä¸Šã«æ‰‹ã‚’ä¿ã¤','è¦ªæŒ‡ã®ä½ç½®ã‚’è¦‹ç›´ã™','ãƒ“ãƒ–ãƒ©ãƒ¼ãƒˆã¯æ‰‹é¦–ã§ã¯ãªãè…•å…¨ä½“ã®å‹•ãã§','ä¼‘æ†©æ™‚ã«æ‰‹é¦–ã®å±ˆä¼¸ã‚¹ãƒˆãƒ¬ãƒƒãƒ'],
          ref: 'Woldendorp KH et al. (2021) PMC7582398 â€” æ‰‹é¦–åä½20Â°è¶…ã§è…±é˜ç‚ãƒªã‚¹ã‚¯3å€ã€‚',
          easyGoodAdvice: 'æ‰‹é¦–ãŒã¾ã£ã™ãã§ã€ã¨ã¦ã‚‚ã„ã„ã‚ˆï¼',
          easyWarnAdvice: 'æ‰‹é¦–ãŒå°‘ã—æ›²ãŒã£ã¦ã„ã‚‹ã‚ˆã€‚è…•ã®å»¶é•·ç·šä¸Šã«æ‰‹ã‚’ä¿ã¨ã†ã€‚',
          easyBadAdvice: 'æ‰‹é¦–ãŒæ›²ãŒã‚Šã™ãï¼æ‰‹é¦–ã‚’ã¾ã£ã™ãã«ã™ã‚‹æ„è­˜ã‚’æŒã¨ã†ã€‚',
          easyTips: ['æ‰‹é¦–ã‚’ã€ŒæŠ˜ã‚‰ãªã„ã€ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ã‚ˆã†','è¦ªæŒ‡ã®ä½ç½®ã‚’è¦‹ç›´ã—ã¦ã¿ã‚ˆã†','ãƒ“ãƒ–ãƒ©ãƒ¼ãƒˆã¯è…•å…¨ä½“ã§','ä¼‘æ†©ä¸­ã«æ‰‹é¦–ã®ã‚¹ãƒˆãƒ¬ãƒƒãƒ']
        }
      }
    }
  },
  trunk: {
    label: 'ä½“å¹¹ãƒ»éª¨ç›¤', icon: 'ğŸ§',
    desc: 'ä½“å¹¹å‚¾æ–œãƒ»éª¨ç›¤æ°´å¹³',
    metrics: ['trunkLean', 'pelvicTilt'],
    skeletonHighlight: [11,12,23,24,25,26],
    cameraGuide: {
      angle: 'æ­£é¢', distance: '2ã€œ3m',
      visibleParts: 'é ­éƒ¨ã€œè†ãŒè¦‹ãˆã‚‹å…¨èº«ã«è¿‘ã„ãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°',
      tips: ['ç«‹å¥ã®å ´åˆã¯è¶³å…ƒã¾ã§æ˜ ã™ã¨ç†æƒ³çš„','åº§å¥ã®å ´åˆã¯æ¤…å­ã«åº§ã£ãŸçŠ¶æ…‹ã§','è‡ªç„¶ãªæ¼”å¥å§¿å‹¢ã‚’ä¿ã£ã¦æ’®å½±','ã‚«ãƒ¡ãƒ©ã¯è…°ã®é«˜ã•ã«è¨­ç½®'],
      svgAngle: 'front'
    },
    deepAnalysis: {
      overview: 'ä½“å¹¹ã¨éª¨ç›¤ã¯æ¼”å¥å§¿å‹¢ã®åœŸå°ã§ã™ã€‚ä½“å¹¹ã®å´æ–¹å‚¾æ–œã‚„éª¨ç›¤ã®éå¯¾ç§°ã¯ã€ä¸ŠåŠèº«ã™ã¹ã¦ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã«å½±éŸ¿ã—ã€é•·æ™‚é–“æ¼”å¥ã§ã®è…°ç—›ã®ä¸»è¦å› ã¨ãªã‚Šã¾ã™ã€‚',
      easyOverview: 'ä½“ã®ä¸­å¿ƒãŒã¾ã£ã™ãã ã¨ã€æ¼”å¥å…¨ä½“ãŒå®‰å®šã™ã‚‹ã‚ˆã€‚å‚¾ã„ã¦ã„ãªã„ã‹ç¢ºèªã—ã¦ã¿ã‚ˆã†ã€‚',
      metrics: {
        trunkLean: {
          name: 'ä½“å¹¹å´æ–¹å‚¾æ–œ',
          goodAdvice: 'ä½“å¹¹ãŒå®‰å®šã—ãŸå‚ç›´ä½ã‚’ä¿ã£ã¦ã„ã¾ã™ã€‚ä¸ŠåŠèº«ã®è‰¯ã„åŸºç›¤ãŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'ä½“å¹¹ã«ã‚„ã‚„å´æ–¹å‚¾æ–œãŒã‚ã‚Šã¾ã™ã€‚é‡å¿ƒã®å·¦å³é…åˆ†ã‚’æ„è­˜ã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'ä½“å¹¹ã®å´æ–¹å‚¾æ–œãŒå¤§ãã„ã§ã™ã€‚è„ŠæŸ±ã¸ã®éå¯¾ç§°ãªè² è·ãŒç¶™ç¶šã—ã¦ã„ã¾ã™ã€‚è…°ç—›ãƒªã‚¹ã‚¯ãŒé«˜ã„çŠ¶æ…‹ã§ã™ã€‚',
          tips: ['ä¸¡è¶³å‡ç­‰è·é‡ã‚’æ„è­˜ã™ã‚‹','éª¨ç›¤ã‚’æ°´å¹³ã«ä¿ã¤æ„è­˜ã‹ã‚‰å§‹ã‚ã‚‹','è…¹æ¨ªç­‹ã®è»½ã„æ´»æ€§åŒ–ï¼ˆãŠè…¹ã‚’è»½ãå¼•ãè¾¼ã‚€ï¼‰','æ¼”å¥ä¸­ã®é¡ãƒã‚§ãƒƒã‚¯ã‚’ç¿’æ…£åŒ–'],
          ref: 'Moraes GFS & Papini AL (2012) â€” ä½“å¹¹å‚¾æ–œã¨è„ŠæŸ±å½æ›²ã®ç›¸é–¢åˆ†æã€‚',
          easyGoodAdvice: 'ä½“ãŒã¾ã£ã™ãã§å®‰å®šã—ã¦ã„ã‚‹ã­ï¼',
          easyWarnAdvice: 'ä½“ãŒå°‘ã—å‚¾ã„ã¦ã„ã‚‹ã‚ˆã€‚ä¸¡è¶³ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãç«‹ã£ã¦ã¿ã‚ˆã†ã€‚',
          easyBadAdvice: 'ä½“ã®å‚¾ããŒå¤§ãã„ã‚ˆï¼è…°ã‹ã‚‰è¦‹ç›´ãã†ã€‚',
          easyTips: ['ä¸¡è¶³ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãç«‹ã¨ã†','ãŠè…¹ã‚’å°‘ã—å¼•ãè¾¼ã‚€æ„è­˜','é¡ã§ãƒã‚§ãƒƒã‚¯ã™ã‚‹ç™–ã‚’ã¤ã‘ã‚ˆã†','ä½“å¹¹ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãŒãŠã™ã™ã‚']
        },
        pelvicTilt: {
          name: 'éª¨ç›¤æ°´å¹³',
          goodAdvice: 'éª¨ç›¤ãŒæ°´å¹³ã«ä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚è„ŠæŸ±ã®è‡ªç„¶ãªå½æ›²ã‚’ç¶­æŒã§ãã¦ã„ã¾ã™ã€‚',
          warnAdvice: 'éª¨ç›¤ã«ã‚„ã‚„å‚¾æ–œãŒã‚ã‚Šã¾ã™ã€‚åº§é¢ã®å¹³å¦æ€§ã‚„è¶³ã®ä½ç½®ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚',
          badAdvice: 'éª¨ç›¤ã®å‚¾æ–œãŒå¤§ãã„ã§ã™ã€‚è„ŠæŸ±ã®Så­—ã‚«ãƒ¼ãƒ–ãŒå´©ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚',
          tips: ['åº§å¥ï¼šåº§é¢ã«ã‚¦ã‚§ãƒƒã‚¸ã‚¯ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨','ç«‹å¥ï¼šè¶³å¹…ã‚’è‚©å¹…ç¨‹åº¦ã«é–‹ã','ç‰‡è¶³é‡å¿ƒã‚’é¿ã‘ä¸¡è¶³å‡ç­‰è·é‡','éª¨ç›¤åº•ç­‹ç¾¤ã®æ„è­˜ã§å®‰å®šæ€§å‘ä¸Š'],
          ref: 'éª¨ç›¤å‚¾æ–œ3Â°ä»¥ä¸Šã§è…°æ¤ã¸ã®éå¯¾ç§°è² è·ãŒå¢—å¤§ã€‚',
          easyGoodAdvice: 'è…°ãŒæ°´å¹³ã§ã„ã„å§¿å‹¢ã ã­ï¼',
          easyWarnAdvice: 'è…°ãŒå°‘ã—å‚¾ã„ã¦ã„ã‚‹ã‚ˆã€‚åº§ã‚Šæ–¹ã‚„ç«‹ã¡æ–¹ã‚’ç¢ºèªã—ã‚ˆã†ã€‚',
          easyBadAdvice: 'è…°ã®å‚¾ããŒå¤§ãã„ã‚ˆï¼ã¾ãšã¯ç«‹ã¡æ–¹ãƒ»åº§ã‚Šæ–¹ã‚’è¦‹ç›´ãã†ã€‚',
          easyTips: ['åº§ã‚‹ã¨ãï¼šãŠå°»ã®ä¸‹ã«ã‚¯ãƒƒã‚·ãƒ§ãƒ³ã‚’æ•·ã„ã¦ã¿ã‚ˆã†','ç«‹ã¤ã¨ãï¼šè¶³ã‚’è‚©å¹…ãã‚‰ã„ã«é–‹ã“ã†','ç‰‡è¶³ã«ä½“é‡ã‚’ã‹ã‘ã™ããªã„ã‚ˆã†ã«','ãŠè…¹ã®åŠ›ã§å®‰å®šã•ã›ã‚ˆã†']
        }
      }
    }
  }
};

const METRIC_DEFS = {
  cva: { id:'cva', name:'é ­é ¸è§’ (CVA)', easyName:'é ­ã®ä½ç½®', unit:'Â°', detail:'å‰æ–¹é ­ä½ã®æ¤œå‡ºã€‚è€³-è‚©ãƒ©ã‚¤ãƒ³ã¨æ°´å¹³ç·šã®è§’åº¦ã€‚', easyDetail:'é ­ãŒå‰ã«å‡ºã™ãã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: >53Â°æ­£å¸¸ / 48-53Â°æ³¨æ„ / <48Â°è­¦å‘Š', getValue:m=>m.cva, getStatus:m=>m.cvaStatus },
  headTilt: { id:'headtilt', name:'é ­éƒ¨å´æ–¹å‚¾æ–œ', easyName:'é ­ã®å‚¾ã', unit:'Â°', detail:'å·¦å³ã®è€³ã®é«˜ä½å·®ã‹ã‚‰ç®—å‡ºã€‚', easyDetail:'é ­ãŒå·¦å³ã«å‚¾ã„ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <5Â°æ­£å¸¸ / 5-10Â°æ³¨æ„ / >10Â°è­¦å‘Š', getValue:m=>Math.abs(m.headTilt), getStatus:m=>m.headTiltStatus, getDirection:m=>m.headTilt>0?'å³':'å·¦' },
  headRot: { id:'headrot', name:'é ­éƒ¨å›æ—‹æ¨å®š', easyName:'é¡”ã®å‘ã', unit:'Â°', detail:'é¼»ã¨ä¸¡è€³ã®ä½ç½®é–¢ä¿‚ã‹ã‚‰å·¦å›æ—‹åº¦ã‚’æ¨å®šã€‚', easyDetail:'é¡”ãŒã©ã‚Œãã‚‰ã„å›ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <15Â°æ­£å¸¸ / 15-30Â°æ³¨æ„ / >30Â°è­¦å‘Š', getValue:m=>Math.abs(m.headRot), getStatus:m=>m.headRotStatus, getDirection:m=>m.headRot>0?'å·¦å›æ—‹':'å³å›æ—‹' },
  lShoulderElev: { id:'lshoulder', name:'å·¦è‚©æŒ™ä¸Š', easyName:'å·¦è‚©ã®é«˜ã•', unit:'%', detail:'å·¦è‚©ã®ä¸Šæ–¹åä½ã€‚ãƒã‚¤ã‚ªãƒªãƒ‹ã‚¹ãƒˆæœ€å¤§ã®æ‚ªç¿’æ…£ã€‚', easyDetail:'å·¦è‚©ãŒä¸ŠãŒã‚Šã™ãã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <3%æ­£å¸¸ / 3-6%æ³¨æ„ / >6%è­¦å‘Š', getValue:m=>m.lShoulderElev, getStatus:m=>m.lShoulderStatus },
  shoulderSym: { id:'shouldersym', name:'è‚©é«˜å·¦å³éå¯¾ç§°', easyName:'è‚©ã®å·¦å³ãƒãƒ©ãƒ³ã‚¹', unit:'Â°', detail:'å·¦å³è‚©ã®Yåº§æ¨™å·®ã‚’è§’åº¦æ›ç®—ã€‚', easyDetail:'ä¸¡è‚©ã®é«˜ã•ãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <5Â°æ­£å¸¸ / 5-10Â°æ³¨æ„ / >10Â°è­¦å‘Š', getValue:m=>m.shoulderSym, getStatus:m=>m.shoulderSymStatus },
  rElbowAbd: { id:'relbow', name:'å³è‚˜å¤–è»¢ï¼ˆå¼“è…•ï¼‰', easyName:'å³è‚˜ï¼ˆå¼“ã®æ‰‹ï¼‰', unit:'Â°', detail:'å³ä¸Šè…•ã®å¤–è»¢è§’ã€‚45Â°ä»¥ä¸‹æ¨å¥¨ã€‚', easyDetail:'å¼“ã‚’æŒã¤æ‰‹ã®è‚˜ã®é«˜ã•ã‚’ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <45Â°æ­£å¸¸ / 45-60Â°æ³¨æ„ / >60Â°è­¦å‘Š', getValue:m=>m.rElbowAbd, getStatus:m=>m.rElbowStatus },
  lElbowAngle: { id:'lelbow', name:'å·¦è‚˜è§’åº¦ï¼ˆæŒ‡æ¿è…•ï¼‰', easyName:'å·¦è‚˜ï¼ˆæŠ¼ã•ãˆã‚‹æ‰‹ï¼‰', unit:'Â°', detail:'è‚©-è‚˜-æ‰‹é¦–ã®è§’åº¦ã€‚', easyDetail:'æŠ¼ã•ãˆã‚‹æ‰‹ã®è‚˜ã®è§’åº¦ã‚’ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: 20-70Â°æ­£å¸¸ / 10-20Â°or70-90Â°æ³¨æ„', getValue:m=>m.lElbowAngle, getStatus:m=>m.lElbowStatus },
  lWristDev: { id:'lwrist', name:'å·¦æ‰‹é¦–åä½', easyName:'å·¦æ‰‹é¦–ã®æ›²ãŒã‚Š', unit:'Â°', detail:'å‰è…•-æ‰‹é¦–-æŒ‡ã®ç›´ç·šã‹ã‚‰ã®åä½ã€‚', easyDetail:'å·¦æ‰‹é¦–ãŒã¾ã£ã™ãã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <10Â°æ­£å¸¸ / 10-20Â°æ³¨æ„ / >20Â°è­¦å‘Š', getValue:m=>m.lWristDev, getStatus:m=>m.lWristStatus },
  trunkLean: { id:'trunk', name:'ä½“å¹¹å´æ–¹å‚¾æ–œ', easyName:'ä½“ã®å‚¾ã', unit:'Â°', detail:'è…°-è‚©ãƒ©ã‚¤ãƒ³ã®å‚ç›´ã‹ã‚‰ã®åä½ã€‚', easyDetail:'ä½“ãŒå‚¾ã„ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <5Â°æ­£å¸¸ / 5-10Â°æ³¨æ„ / >10Â°è­¦å‘Š', getValue:m=>Math.abs(m.trunkLean), getStatus:m=>m.trunkStatus, getDirection:m=>m.trunkLean>0?'å³':'å·¦' },
  pelvicTilt: { id:'pelvic', name:'éª¨ç›¤æ°´å¹³', easyName:'è…°ã®æ°´å¹³', unit:'Â°', detail:'å·¦å³ã®è…°ã®Yåº§æ¨™å·®ã€‚', easyDetail:'è…°ãŒæ°´å¹³ã‹ãƒã‚§ãƒƒã‚¯', ref:'åŸºæº–: <3Â°æ­£å¸¸ / 3-5Â°æ³¨æ„ / >5Â°è­¦å‘Š', getValue:m=>m.pelvicTilt, getStatus:m=>m.pelvicStatus }
};

// Readiness checks: which landmarks must be visible before starting measurement
const READINESS_CHECKS = {
  head: [
    { label: 'é¡”', landmarks: [0], threshold: 0.5 },
    { label: 'è€³ï¼ˆç‰‡æ–¹ã§OKï¼‰', landmarks: [7, 8], threshold: 0.3, anyOf: true },
    { label: 'ä¸¡è‚©', landmarks: [11, 12], threshold: 0.5 },
  ],
  shoulders: [
    { label: 'ä¸¡è‚©', landmarks: [11, 12], threshold: 0.5 },
    { label: 'ä¸¡è‚˜', landmarks: [13, 14], threshold: 0.4 },
    { label: 'è…°', landmarks: [23, 24], threshold: 0.5 },
  ],
  'bow-arm': [
    { label: 'å³è‚©', landmarks: [12], threshold: 0.5 },
    { label: 'å³è‚˜', landmarks: [14], threshold: 0.5 },
    { label: 'å³æ‰‹é¦–', landmarks: [16], threshold: 0.4 },
  ],
  'finger-arm': [
    { label: 'å·¦è‚©', landmarks: [11], threshold: 0.5 },
    { label: 'å·¦è‚˜', landmarks: [13], threshold: 0.5 },
    { label: 'å·¦æ‰‹é¦–', landmarks: [15], threshold: 0.4 },
  ],
  trunk: [
    { label: 'ä¸¡è‚©', landmarks: [11, 12], threshold: 0.5 },
    { label: 'è…°', landmarks: [23, 24], threshold: 0.5 },
  ],
  all: [
    { label: 'é¡”', landmarks: [0], threshold: 0.1 },
    { label: 'ä¸¡è‚©', landmarks: [11, 12], threshold: 0.1, anyOf: true },
    { label: 'ä¸¡è…•ï¼ˆè‚˜ï¼‰', landmarks: [13, 14], threshold: 0.1, anyOf: true },
  ],
};
const READINESS_PASS_NEEDED = 3; // frames needed (è“„ç©å¼: é€£ç¶šã§ãªãã¦ã‚‚OK)
let readinessFailStreak = 0; // é€£ç¶šå¤±æ•—ã‚«ã‚¦ãƒ³ãƒˆï¼ˆ10é€£ç¶šå¤±æ•—ã§ãƒªã‚»ãƒƒãƒˆï¼‰

// =============================================================================
// STATE
// =============================================================================
let poseLandmarker = null;
let drawingUtils = null;
let stream = null;
let running = false;
let lastVideoTime = -1;
let frameCount = 0;
let fpsTime = 0;
let currentFps = 0;
let isRecording = false;
let recordStartTime = 0;
let recordFrames = [];
let snapshots = [];
let facingMode = "user";
let smoothedMetrics = null;
let selectedArea = null;
let currentScreen = 'select';
let measurementData = [];
let isMeasuring = false;
let measureStartTime = 0;
let _detectFrameId = 0; // detectLoopã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿ï¼ˆé‡è¤‡åé›†é˜²æ­¢ç”¨ï¼‰
let _activeDataInterval = null; // è¨ˆæ¸¬ç”¨intervalï¼ˆäºŒé‡èµ·å‹•é˜²æ­¢ï¼‰
let pipActive = false;
let pipObserver = null;
let isCheckingReadiness = false;
let readinessPassCount = 0;
let viewMode = localStorage.getItem('vp-viewMode') || 'teacher';
function isEasyMode() { return viewMode === 'easy'; }

const ALPHA = 0.3;

// DOM refs
const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");
const fpsBadge = document.getElementById("fpsBadge");
const recordingBadge = document.getElementById("recordingBadge");
const btnRecord = document.getElementById("btnRecord");
const btnSnapshot = document.getElementById("btnSnapshot");
const cameraSelect = document.getElementById("cameraSelect");
const smoothingInfo = document.getElementById("smoothingInfo");
const loadingScreen = document.getElementById("loadingScreen");
const loadingProgress = document.getElementById("loadingProgress");

// =============================================================================
// INITIALIZATION
// =============================================================================
async function init() {
  try {
    loadingProgress.textContent = "WASM ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’èª­ã¿è¾¼ã¿ä¸­...";
    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm"
    );
    loadingProgress.textContent = "å§¿å‹¢æ¨å®šãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...ï¼ˆåˆå›ã¯30ç§’ã»ã©ã‹ã‹ã‚Šã¾ã™ï¼‰";
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO", numPoses: 1,
      minPoseDetectionConfidence: 0.15, minPosePresenceConfidence: 0.15, minTrackingConfidence: 0.15,
      outputSegmentationMasks: false
    });
    drawingUtils = new DrawingUtils(ctx);
    loadingProgress.textContent = "æº–å‚™å®Œäº†";
    setTimeout(() => loadingScreen.classList.add("hidden"), 400);
  } catch (e) {
    try {
      loadingProgress.textContent = "GPUåˆæœŸåŒ–å¤±æ•—ã€CPUãƒ¢ãƒ¼ãƒ‰ã§å†è©¦è¡Œä¸­...";
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm"
      );
      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO", numPoses: 1,
        minPoseDetectionConfidence: 0.5, minPosePresenceConfidence: 0.5, minTrackingConfidence: 0.5,
        outputSegmentationMasks: false
      });
      drawingUtils = new DrawingUtils(ctx);
      loadingProgress.textContent = "æº–å‚™å®Œäº†ï¼ˆCPUãƒ¢ãƒ¼ãƒ‰ï¼‰";
      setTimeout(() => loadingScreen.classList.add("hidden"), 400);
    } catch (e2) {
      loadingProgress.textContent = "ã‚¨ãƒ©ãƒ¼: " + e2.message;
    }
  }
}

// =============================================================================
// CAMERA
// =============================================================================
async function startCamera() {
  if (stream) { stream.getTracks().forEach(t => t.stop()); }
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    const isMirrored = facingMode === "user";
    video.classList.toggle("mirror", isMirrored);
    overlay.classList.toggle("mirror", isMirrored);
    video.addEventListener("loadeddata", onVideoReady, { once: true });
    video.addEventListener("canplay", onVideoReady, { once: true });
  } catch (e) {
    alert("ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“: " + e.message);
  }
}

function onVideoReady() {
  if (running) return;
  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;
  running = true;
  document.getElementById("noCameraMsg").style.display = "none";
  fpsBadge.style.display = "block";
  cameraSelect.style.display = "block";
  smoothingInfo.style.display = "block";
  btnRecord.disabled = false;
  btnSnapshot.disabled = false;
  detectLoop();
}

// =============================================================================
// MATH UTILS
// =============================================================================
function rad2deg(r) { return r * 180 / Math.PI; }
function deg2rad(d) { return d * Math.PI / 180; }
function angle2D(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax); }
function angleBetween3(ax, ay, bx, by, cx, cy) {
  const ba = { x: ax - bx, y: ay - by };
  const bc = { x: cx - bx, y: cy - by };
  const dot = ba.x * bc.x + ba.y * bc.y;
  const magBA = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
  const magBC = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
  if (magBA === 0 || magBC === 0) return 0;
  return rad2deg(Math.acos(Math.max(-1, Math.min(1, dot / (magBA * magBC)))));
}
function ema(prev, curr, alpha) { if (prev === null) return curr; return prev + alpha * (curr - prev); }

// =============================================================================
// POSTURE ANALYSIS
// =============================================================================
function analyzePosture(landmarks) {
  const w = overlay.width, h = overlay.height;
  const px = (lm) => lm.x * w, py = (lm) => lm.y * h;
  const nose=landmarks[0], lEar=landmarks[7], rEar=landmarks[8];
  const lShoulder=landmarks[11], rShoulder=landmarks[12];
  const lElbow=landmarks[13], rElbow=landmarks[14];
  const lWrist=landmarks[15], rWrist=landmarks[16];
  const lIndex=landmarks[19], rIndex=landmarks[20];
  const lHip=landmarks[23], rHip=landmarks[24];
  const results = {};
  // è…°ãŒãƒ•ãƒ¬ãƒ¼ãƒ å¤–ï¼ˆæ¨å®šå€¤ï¼‰ã‹ã©ã†ã‹åˆ¤å®š
  const hipInFrame = lHip.y < 1.05 && lHip.y > -0.05 && rHip.y < 1.05 && rHip.y > -0.05;
  results.hipEstimated = !hipInFrame;
  const useLeftEar = (lEar.visibility||0) >= (rEar.visibility||0);
  const ear = useLeftEar ? lEar : rEar;
  const shoulder = useLeftEar ? lShoulder : rShoulder;
  results.cva = rad2deg(Math.atan2(py(shoulder)-py(ear), Math.abs(px(ear)-px(shoulder))));
  results.cvaStatus = results.cva>53?"good":results.cva>48?"warn":"bad";
  const earDy=py(lEar)-py(rEar), earDx=px(rEar)-px(lEar);
  let rawTilt = rad2deg(Math.atan2(earDy, earDx));
  // [-90, 90] ã«æ­£è¦åŒ–ï¼ˆ180Â°ä»˜è¿‘ã®ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰é˜²æ­¢ï¼‰
  if (rawTilt > 90) rawTilt = 180 - rawTilt;
  else if (rawTilt < -90) rawTilt = -180 - rawTilt;
  results.headTilt = rawTilt;
  results.headTiltStatus = Math.abs(results.headTilt)<5?"good":Math.abs(results.headTilt)<10?"warn":"bad";
  const noseToLEar=Math.sqrt((px(nose)-px(lEar))**2+(py(nose)-py(lEar))**2);
  const noseToREar=Math.sqrt((px(nose)-px(rEar))**2+(py(nose)-py(rEar))**2);
  const earRatio=(noseToLEar>0&&noseToREar>0)?(noseToREar-noseToLEar)/(noseToREar+noseToLEar):0;
  results.headRot = earRatio*100;
  results.headRotStatus = Math.abs(results.headRot)<15?"good":Math.abs(results.headRot)<30?"warn":"bad";
  const torsoH=((py(lHip)+py(rHip))/2)-((py(lShoulder)+py(rShoulder))/2);
  const shoulderDy=py(rShoulder)-py(lShoulder);
  results.lShoulderElev = torsoH>0?(shoulderDy/torsoH)*100:0;
  results.lShoulderStatus = results.lShoulderElev<3?"good":results.lShoulderElev<6?"warn":"bad";
  const shoulderDist=Math.abs(px(rShoulder)-px(lShoulder));
  results.shoulderSym = shoulderDist>0?rad2deg(Math.atan2(Math.abs(py(lShoulder)-py(rShoulder)),shoulderDist)):0;
  results.shoulderSymStatus = results.shoulderSym<5?"good":results.shoulderSym<10?"warn":"bad";
  // å³ä¸Šè…•ã®å‚ç›´ä¸‹å‘ã(Ï€/2)ã‹ã‚‰ã®è§’åº¦å·®ã‚’æ­£è¦åŒ–
  const armRad = angle2D(px(rShoulder),py(rShoulder),px(rElbow),py(rElbow));
  let abdDiff = armRad - Math.PI/2;
  if (abdDiff > Math.PI) abdDiff -= 2*Math.PI;
  if (abdDiff < -Math.PI) abdDiff += 2*Math.PI;
  results.rElbowAbd = Math.abs(rad2deg(abdDiff));
  results.rElbowStatus = results.rElbowAbd<45?"good":results.rElbowAbd<60?"warn":"bad";
  results.rElbowAboveShoulder = py(rElbow)<py(rShoulder);
  results.lElbowAngle = angleBetween3(px(lShoulder),py(lShoulder),px(lElbow),py(lElbow),px(lWrist),py(lWrist));
  results.lElbowStatus = (results.lElbowAngle>=20&&results.lElbowAngle<=70)?"good":((results.lElbowAngle>=10&&results.lElbowAngle<20)||(results.lElbowAngle>70&&results.lElbowAngle<=90))?"warn":"bad";
  const wristAngle=angleBetween3(px(lElbow),py(lElbow),px(lWrist),py(lWrist),px(lIndex),py(lIndex));
  results.lWristDev = Math.abs(180-wristAngle);
  results.lWristStatus = results.lWristDev<10?"good":results.lWristDev<20?"warn":"bad";
  const midHipX=(px(lHip)+px(rHip))/2, midHipY=(py(lHip)+py(rHip))/2;
  const midShoulderX=(px(lShoulder)+px(rShoulder))/2, midShoulderY=(py(lShoulder)+py(rShoulder))/2;
  results.trunkLean = rad2deg(Math.atan2(midShoulderX-midHipX, midHipY-midShoulderY));
  results.trunkStatus = Math.abs(results.trunkLean)<5?"good":Math.abs(results.trunkLean)<10?"warn":"bad";
  const hipDist=Math.abs(px(rHip)-px(lHip));
  results.pelvicTilt = hipDist>0?rad2deg(Math.atan2(Math.abs(py(lHip)-py(rHip)),hipDist)):0;
  results.pelvicStatus = results.pelvicTilt<3?"good":results.pelvicTilt<5?"warn":"bad";
  const statusScores={good:0,warn:1,bad:2};
  const allStatuses=[results.cvaStatus,results.headTiltStatus,results.headRotStatus,results.lShoulderStatus,results.shoulderSymStatus,results.rElbowStatus,results.lElbowStatus,results.lWristStatus,results.trunkStatus,results.pelvicStatus];
  const totalBad=allStatuses.reduce((s,v)=>s+statusScores[v],0);
  results.rula = Math.round(Math.min(7,Math.max(1,1+(totalBad/20)*6))*10)/10;
  return results;
}

function smoothMetricsF(raw) {
  if (!smoothedMetrics) { smoothedMetrics = { ...raw }; return smoothedMetrics; }
  const numKeys=["cva","headTilt","headRot","lShoulderElev","shoulderSym","rElbowAbd","lElbowAngle","lWristDev","trunkLean","pelvicTilt","rula"];
  for (const k of numKeys) { if (typeof raw[k]==="number") smoothedMetrics[k]=ema(smoothedMetrics[k],raw[k],ALPHA); }
  const statusKeys=["cvaStatus","headTiltStatus","headRotStatus","lShoulderStatus","shoulderSymStatus","rElbowStatus","lElbowStatus","lWristStatus","trunkStatus","pelvicStatus","rElbowAboveShoulder","hipEstimated"];
  for (const k of statusKeys) smoothedMetrics[k]=raw[k];
  return smoothedMetrics;
}

// =============================================================================
// NAVIGATION
// =============================================================================
function navigateTo(screenName) {
  currentScreen = screenName;
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const map = { select:'screenSelect', guide:'screenGuide', live:'screenLive', report:'screenReport' };
  document.getElementById(map[screenName]).classList.add('active');
  window.scrollTo(0, 0);
  // Hide PiP when not on live screen
  if (screenName !== 'live') {
    document.getElementById('cameraPip').style.display = 'none';
    pipActive = false;
  }
}

// =============================================================================
// S1: BUILD FOCUS GRID
// =============================================================================
function buildFocusGrid() {
  const grid = document.getElementById('focusGrid');
  grid.innerHTML = '';
  for (const [key, area] of Object.entries(FOCUS_AREAS)) {
    const card = document.createElement('div');
    card.className = 'focus-card';
    card.innerHTML = `<div class="focus-icon">${area.icon}</div><div class="focus-label">${area.label}</div><div class="focus-desc">${area.desc}</div>`;
    card.addEventListener('click', () => {
      selectedArea = key;
      buildGuideContent();
      navigateTo('guide');
    });
    grid.appendChild(card);
  }
}

// =============================================================================
// S2: CAMERA GUIDE
// =============================================================================
function generateGuideSVG(area) {
  const guide = area.cameraGuide;
  const isSide = guide.svgAngle === 'side';
  // Simple stick figure with camera position indicator
  return `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg" style="max-width:200px;">
    <!-- Person -->
    <circle cx="100" cy="30" r="14" fill="none" stroke="#448aff" stroke-width="2"/>
    <line x1="100" y1="44" x2="100" y2="90" stroke="#448aff" stroke-width="2"/>
    <line x1="100" y1="55" x2="${isSide?'80':'70'}" y2="75" stroke="#448aff" stroke-width="2"/>
    <line x1="100" y1="55" x2="${isSide?'85':'130'}" y2="75" stroke="#448aff" stroke-width="2"/>
    <line x1="100" y1="90" x2="85" y2="120" stroke="#448aff" stroke-width="2"/>
    <line x1="100" y1="90" x2="115" y2="120" stroke="#448aff" stroke-width="2"/>
    ${isSide ? `
    <!-- Camera from side -->
    <rect x="20" y="45" width="24" height="18" rx="3" fill="none" stroke="#00e676" stroke-width="2"/>
    <circle cx="32" cy="54" r="5" fill="none" stroke="#00e676" stroke-width="1.5"/>
    <line x1="44" y1="54" x2="80" y2="50" stroke="#00e676" stroke-width="1" stroke-dasharray="4,3"/>
    <text x="15" y="78" fill="#8888a0" font-size="9">ğŸ“·</text>
    ` : `
    <!-- Camera from front -->
    <rect x="88" y="138" width="24" height="18" rx="3" fill="none" stroke="#00e676" stroke-width="2"/>
    <circle cx="100" cy="147" r="5" fill="none" stroke="#00e676" stroke-width="1.5"/>
    <line x1="100" y1="138" x2="100" y2="125" stroke="#00e676" stroke-width="1" stroke-dasharray="4,3"/>
    <text x="110" y="152" fill="#8888a0" font-size="9">ğŸ“·</text>
    `}
    <!-- Highlight area -->
    ${area.skeletonHighlight.includes(0) ? '<circle cx="100" cy="30" r="20" fill="rgba(68,138,255,0.1)" stroke="rgba(68,138,255,0.3)" stroke-width="1" stroke-dasharray="3,2"/>' : ''}
    ${area.skeletonHighlight.includes(14) && !area.skeletonHighlight.includes(13) ? '<ellipse cx="130" cy="65" rx="25" ry="20" fill="rgba(68,138,255,0.1)" stroke="rgba(68,138,255,0.3)" stroke-width="1" stroke-dasharray="3,2"/>' : ''}
    ${area.skeletonHighlight.includes(13) && !area.skeletonHighlight.includes(14) ? '<ellipse cx="75" cy="65" rx="25" ry="20" fill="rgba(68,138,255,0.1)" stroke="rgba(68,138,255,0.3)" stroke-width="1" stroke-dasharray="3,2"/>' : ''}
    ${area.skeletonHighlight.includes(23) && area.skeletonHighlight.includes(24) && !area.skeletonHighlight.includes(0) ? '<ellipse cx="100" cy="95" rx="30" ry="30" fill="rgba(68,138,255,0.1)" stroke="rgba(68,138,255,0.3)" stroke-width="1" stroke-dasharray="3,2"/>' : ''}
  </svg>`;
}

function getActiveMetrics() {
  if (selectedArea === 'all') return Object.keys(METRIC_DEFS);
  return FOCUS_AREAS[selectedArea].metrics;
}

function buildGuideContent() {
  const content = document.getElementById('guideContent');
  if (selectedArea === 'all') {
    content.innerHTML = `
      <div class="guide-angle-box">
        <svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg" style="max-width:200px;">
          <circle cx="100" cy="30" r="14" fill="none" stroke="#448aff" stroke-width="2"/>
          <line x1="100" y1="44" x2="100" y2="90" stroke="#448aff" stroke-width="2"/>
          <line x1="100" y1="55" x2="70" y2="75" stroke="#448aff" stroke-width="2"/>
          <line x1="100" y1="55" x2="130" y2="75" stroke="#448aff" stroke-width="2"/>
          <line x1="100" y1="90" x2="85" y2="120" stroke="#448aff" stroke-width="2"/>
          <line x1="100" y1="90" x2="115" y2="120" stroke="#448aff" stroke-width="2"/>
          <rect x="88" y="138" width="24" height="18" rx="3" fill="none" stroke="#00e676" stroke-width="2"/>
          <circle cx="100" cy="147" r="5" fill="none" stroke="#00e676" stroke-width="1.5"/>
          <line x1="100" y1="138" x2="100" y2="125" stroke="#00e676" stroke-width="1" stroke-dasharray="4,3"/>
          <ellipse cx="100" cy="70" rx="50" ry="55" fill="rgba(68,138,255,0.08)" stroke="rgba(68,138,255,0.25)" stroke-width="1" stroke-dasharray="3,2"/>
        </svg>
        <div class="guide-angle-title">æ­£é¢</div>
        <div class="guide-angle-sub">æ¨å¥¨è·é›¢: 50cmã€œ1m</div>
        <div class="guide-angle-sub" style="margin-top:4px;">ä¸ŠåŠèº«ãŒæ˜ ã‚Œã°OKï¼ˆè…°ã‹ã‚‰ä¸‹ã¯æ˜ ã‚‰ãªãã¦å¤§ä¸ˆå¤«ï¼‰</div>
      </div>
      <div class="guide-tips">
        <h3>å…¨èº«è¨ºæ–­ã®æ’®å½±ãƒã‚¤ãƒ³ãƒˆ</h3>
        <ul>
          <li>é ­ã‹ã‚‰èƒ¸ã‚ãŸã‚Šã¾ã§æ˜ ã£ã¦ã„ã‚Œã°OK</li>
          <li>ãƒã‚¤ã‚ªãƒªãƒ³ã‚’æ§‹ãˆãŸæ¼”å¥å§¿å‹¢ã§æ’®å½±</li>
          <li>æ˜ã‚‹ã„å ´æ‰€ãƒ»ã‚·ãƒ³ãƒ—ãƒ«ãªèƒŒæ™¯ãŒç†æƒ³çš„</li>
          <li>15ç§’é–“ã€æ™®æ®µé€šã‚Šã«æ¼”å¥ã—ã¦ãã ã•ã„</li>
          <li>ä½“å¹¹ãƒ»éª¨ç›¤ã¯ä¸ŠåŠèº«ã‹ã‚‰æ¨å®šã—ã¾ã™</li>
        </ul>
      </div>
    `;
    return;
  }
  const area = FOCUS_AREAS[selectedArea];
  const guide = area.cameraGuide;
  content.innerHTML = `
    <div class="guide-angle-box">
      ${generateGuideSVG(area)}
      <div class="guide-angle-title">${guide.angle}</div>
      <div class="guide-angle-sub">æ¨å¥¨è·é›¢: ${guide.distance}</div>
      <div class="guide-angle-sub" style="margin-top:4px;">${guide.visibleParts}</div>
    </div>
    <div class="guide-tips">
      <h3>${area.label}ã®æ’®å½±ãƒã‚¤ãƒ³ãƒˆ</h3>
      <ul>${guide.tips.map(t => `<li>${t}</li>`).join('')}</ul>
    </div>
  `;
}

// =============================================================================
// S3: BUILD METRIC CARDS
// =============================================================================
function buildMetricCards() {
  const metricKeys = getActiveMetrics();
  const container = document.getElementById('metricCards');
  const easy = isEasyMode();
  container.innerHTML = metricKeys.map(key => {
    const def = METRIC_DEFS[key];
    const name = easy ? (def.easyName || def.name) : def.name;
    const detail = easy ? (def.easyDetail || def.detail) : def.detail;
    return `<div class="metric-card status-none" id="card-${def.id}">
      <div class="metric-header">
        <div class="metric-name">${name}</div>
        <div class="metric-badge" id="badge-${def.id}">--</div>
      </div>
      <div class="metric-value" id="val-${def.id}">--${def.unit}</div>
      <div class="metric-detail">${detail}</div>
      ${easy ? '' : `<div class="metric-ref">${def.ref}</div>`}
    </div>`;
  }).join('');
}

// =============================================================================
// UI UPDATE
// =============================================================================
const statusLabelsTeacher = { good:"æ­£å¸¸", warn:"æ³¨æ„", bad:"è­¦å‘Š" };
const statusLabelsEasy = { good:"ã„ã„ã­ï¼ğŸ‘", warn:"ã‚‚ã†ã¡ã‚‡ã£ã¨ï¼ğŸ’ª", bad:"ãã‚’ã¤ã‘ã¦ï¼âš ï¸" };
const badgeClasses = { good:"badge-good", warn:"badge-warn", bad:"badge-bad" };
const cardClasses = { good:"status-good", warn:"status-warn", bad:"status-bad" };

function getStatusLabel(status) {
  return isEasyMode() ? (statusLabelsEasy[status]||"--") : (statusLabelsTeacher[status]||"--");
}
function getMetricName(key) {
  const def = METRIC_DEFS[key];
  return isEasyMode() ? (def.easyName || def.name) : def.name;
}
function getMetricDetail(key) {
  const def = METRIC_DEFS[key];
  return isEasyMode() ? (def.easyDetail || def.detail) : def.detail;
}
function getRulaLevelText(rula) {
  if (isEasyMode()) {
    if (rula<=2) return 'ã¨ã¦ã‚‚ã„ã„ã‚ˆï¼ğŸŒŸ';
    if (rula<=4) return 'ã‚ã‚‹ããªã„ã‚ˆï¼ğŸ‘€';
    if (rula<=6) return 'ã‚‚ã†ã™ã“ã—ãªãŠãã†ï¼ğŸ’ª';
    return 'ã™ããªãŠãã†ï¼ğŸ”¥';
  }
  if (rula<=2) return 'è‰¯å¥½';
  if (rula<=4) return 'è¦è¦³å¯Ÿ';
  if (rula<=6) return 'è¦æ”¹å–„';
  return 'å±é™º';
}

function updateUI(m) {
  if (!selectedArea) return;
  const metricKeys = getActiveMetrics();
  for (const key of metricKeys) {
    const def = METRIC_DEFS[key];
    const val = def.getValue(m);
    const status = def.getStatus(m);
    const card = document.getElementById(`card-${def.id}`);
    const badge = document.getElementById(`badge-${def.id}`);
    const valEl = document.getElementById(`val-${def.id}`);
    if (!card) continue;
    card.className = `metric-card ${cardClasses[status]||"status-none"}`;
    badge.className = `metric-badge ${badgeClasses[status]||""}`;
    badge.textContent = getStatusLabel(status);
    const isEstimated = m.hipEstimated && (key === 'trunkLean' || key === 'pelvicTilt');
    let dirText = '';
    if (def.getDirection && val > 2) {
      dirText = ' (' + def.getDirection(m) + ')';
    }
    valEl.textContent = val.toFixed(1) + def.unit + dirText + (isEstimated ? ' æ¨å®š' : '');
  }
  // RULA bar
  const rula = m.rula;
  const rulaFill = document.getElementById("rulaFill");
  const rulaScore = document.getElementById("rulaScore");
  const rulaLevel = document.getElementById("rulaLevel");
  const pct = ((rula-1)/6)*100;
  rulaFill.style.width = pct+"%";
  rulaScore.textContent = rula.toFixed(1);
  if (rula<=2) { rulaFill.style.background="var(--green)"; rulaScore.style.color="var(--green)"; rulaLevel.style.background="rgba(0,230,118,0.15)"; rulaLevel.style.color="var(--green)"; }
  else if (rula<=4) { rulaFill.style.background="var(--yellow)"; rulaScore.style.color="var(--yellow)"; rulaLevel.style.background="rgba(255,215,64,0.15)"; rulaLevel.style.color="var(--yellow)"; }
  else if (rula<=6) { rulaFill.style.background="#ff9100"; rulaScore.style.color="#ff9100"; rulaLevel.style.background="rgba(255,145,0,0.15)"; rulaLevel.style.color="#ff9100"; }
  else { rulaFill.style.background="var(--red)"; rulaScore.style.color="var(--red)"; rulaLevel.style.background="rgba(255,82,82,0.15)"; rulaLevel.style.color="var(--red)"; }
  rulaLevel.textContent = getRulaLevelText(rula);
}

// =============================================================================
// SKELETON DRAWING
// =============================================================================
function drawSkeleton(landmarks, metrics) {
  ctx.save();
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  if (!landmarks || landmarks.length === 0) { ctx.restore(); return; }
  const lm = landmarks, w = overlay.width, h = overlay.height;
  const connections = PoseLandmarker.POSE_CONNECTIONS;
  const highlight = (selectedArea && selectedArea !== 'all') ? new Set(FOCUS_AREAS[selectedArea].skeletonHighlight) : null;

  function getRegionColor(startIdx, endIdx) {
    if ([0,1,2,3,4,5,6,7,8,9,10].includes(startIdx)&&[0,1,2,3,4,5,6,7,8,9,10].includes(endIdx)){
      const ok=metrics.cvaStatus==="good"&&metrics.headTiltStatus==="good";
      return ok?"rgba(0,230,118,0.8)":metrics.cvaStatus==="bad"||metrics.headTiltStatus==="bad"?"rgba(255,82,82,0.8)":"rgba(255,215,64,0.8)";
    }
    if ([11,13,15,17,19,21].includes(startIdx)&&[11,13,15,17,19,21].includes(endIdx)){
      const ok=metrics.lElbowStatus==="good"&&metrics.lWristStatus==="good";
      return ok?"rgba(0,230,118,0.8)":(metrics.lElbowStatus==="bad"||metrics.lWristStatus==="bad")?"rgba(255,82,82,0.8)":"rgba(255,215,64,0.8)";
    }
    if ([12,14,16,18,20,22].includes(startIdx)&&[12,14,16,18,20,22].includes(endIdx)){
      return metrics.rElbowStatus==="good"?"rgba(0,230,118,0.8)":metrics.rElbowStatus==="bad"?"rgba(255,82,82,0.8)":"rgba(255,215,64,0.8)";
    }
    if (([11,12].includes(startIdx)&&[11,12].includes(endIdx))||([23,24].includes(startIdx)&&[23,24].includes(endIdx))||(startIdx===11&&endIdx===23)||(startIdx===12&&endIdx===24)){
      const ok=metrics.trunkStatus==="good"&&metrics.shoulderSymStatus==="good";
      return ok?"rgba(0,230,118,0.8)":(metrics.trunkStatus==="bad"||metrics.shoulderSymStatus==="bad")?"rgba(255,82,82,0.8)":"rgba(255,215,64,0.8)";
    }
    return "rgba(100,200,255,0.6)";
  }

  for (const conn of connections) {
    const s=conn.start, e=conn.end;
    const sl=lm[s], el=lm[e];
    if ((sl.visibility||0)<0.3||(el.visibility||0)<0.3) continue;
    const isHighlighted = !highlight || (highlight.has(s) && highlight.has(e));
    const color = getRegionColor(s, e);
    ctx.beginPath();
    ctx.moveTo(sl.x*w, sl.y*h);
    ctx.lineTo(el.x*w, el.y*h);
    ctx.globalAlpha = isHighlighted ? 1.0 : 0.2;
    ctx.strokeStyle = isHighlighted ? color : "rgba(100,200,255,0.4)";
    ctx.lineWidth = isHighlighted ? 3 : 1.5;
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  for (let i = 0; i < lm.length; i++) {
    if ((lm[i].visibility||0)<0.3) continue;
    const isH = !highlight || highlight.has(i);
    ctx.beginPath();
    ctx.arc(lm[i].x*w, lm[i].y*h, isH?4:2, 0, Math.PI*2);
    ctx.fillStyle = isH?"rgba(255,255,255,0.9)":"rgba(255,255,255,0.25)";
    ctx.fill();
    if (isH) { ctx.strokeStyle="rgba(0,0,0,0.5)"; ctx.lineWidth=1; ctx.stroke(); }
  }

  // Angle annotations
  if (!selectedArea || FOCUS_AREAS[selectedArea].metrics.includes('lElbowAngle')) {
    drawAngleArc(lm, 11, 13, 15, metrics.lElbowAngle, w, h);
  }
  if (!selectedArea || FOCUS_AREAS[selectedArea].metrics.includes('cva')) {
    drawCVALine(lm, metrics.cva, w, h);
  }
  ctx.restore();
}

function drawAngleArc(lm, a, b, c, angle, w, h) {
  if ((lm[b].visibility||0)<0.3) return;
  const bx=lm[b].x*w, by=lm[b].y*h;
  ctx.save();
  ctx.font="bold 11px monospace";
  ctx.fillStyle="rgba(255,255,255,0.9)";
  ctx.strokeStyle="rgba(0,0,0,0.6)";
  ctx.lineWidth=2;
  const text=Math.round(angle)+"Â°";
  ctx.strokeText(text, bx+8, by-8);
  ctx.fillText(text, bx+8, by-8);
  ctx.restore();
}

function drawCVALine(lm, cva, w, h) {
  const ear=(lm[7].visibility||0)>=(lm[8].visibility||0)?lm[7]:lm[8];
  const shoulder=(lm[7].visibility||0)>=(lm[8].visibility||0)?lm[11]:lm[12];
  if ((ear.visibility||0)<0.3||(shoulder.visibility||0)<0.3) return;
  const ex=ear.x*w,ey=ear.y*h,sx=shoulder.x*w,sy=shoulder.y*h;
  ctx.save();
  ctx.setLineDash([4,4]);
  ctx.strokeStyle="rgba(180,136,255,0.7)";
  ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(sx-30,sy); ctx.lineTo(sx+30,sy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(sx,sy); ctx.stroke();
  ctx.setLineDash([]);
  ctx.font="bold 11px monospace";
  ctx.fillStyle="rgba(180,136,255,0.9)";
  ctx.strokeStyle="rgba(0,0,0,0.6)";
  ctx.lineWidth=2;
  const label="CVA "+Math.round(cva)+"Â°";
  const mx=(ex+sx)/2+6, my=(ey+sy)/2;
  ctx.strokeText(label,mx,my);
  ctx.fillText(label,mx,my);
  ctx.restore();
}

// =============================================================================
// PiP CAMERA
// =============================================================================
function setupPiP() {
  const cameraSection = document.getElementById('cameraSection');
  const pip = document.getElementById('cameraPip');
  const videoPip = document.getElementById('videoPip');
  if (pipObserver) pipObserver.disconnect();
  pipObserver = new IntersectionObserver((entries) => {
    if (currentScreen !== 'live' || !running) return;
    const entry = entries[0];
    if (!entry.isIntersecting) {
      videoPip.srcObject = video.srcObject;
      videoPip.classList.toggle('mirror', video.classList.contains('mirror'));
      pip.style.display = 'block';
      pipActive = true;
    } else {
      pip.style.display = 'none';
      pipActive = false;
    }
  }, { threshold: 0.3 });
  pipObserver.observe(cameraSection);
  pip.addEventListener('click', () => { cameraSection.scrollIntoView({ behavior:'smooth' }); });
}

// =============================================================================
// DETECTION LOOP
// =============================================================================
function detectLoop() {
  if (!running) return;
  requestAnimationFrame(detectLoop);
  if (!poseLandmarker || video.readyState < 2) return;
  const t = video.currentTime;
  if (t === lastVideoTime) return;
  lastVideoTime = t;
  const ts = performance.now();
  const result = poseLandmarker.detectForVideo(video, ts);
  frameCount++;
  const hasLandmarks = result.landmarks && result.landmarks.length > 0;
  if (ts - fpsTime >= 1000) { currentFps = frameCount; frameCount = 0; fpsTime = ts; fpsBadge.textContent = currentFps + " FPS"; }

  if (hasLandmarks) {
    try {
      const rawMetrics = analyzePosture(result.landmarks[0]);
      const sm = smoothMetricsF(rawMetrics);
      sm.cvaStatus = sm.cva>53?"good":sm.cva>48?"warn":"bad";
      sm.headTiltStatus = Math.abs(sm.headTilt)<5?"good":Math.abs(sm.headTilt)<10?"warn":"bad";
      sm.headRotStatus = Math.abs(sm.headRot)<15?"good":Math.abs(sm.headRot)<30?"warn":"bad";
      sm.lShoulderStatus = sm.lShoulderElev<3?"good":sm.lShoulderElev<6?"warn":"bad";
      sm.shoulderSymStatus = sm.shoulderSym<5?"good":sm.shoulderSym<10?"warn":"bad";
      sm.rElbowStatus = sm.rElbowAbd<45?"good":sm.rElbowAbd<60?"warn":"bad";
      sm.lElbowStatus = (sm.lElbowAngle>=20&&sm.lElbowAngle<=70)?"good":((sm.lElbowAngle>=10&&sm.lElbowAngle<20)||(sm.lElbowAngle>70&&sm.lElbowAngle<=90))?"warn":"bad";
      sm.lWristStatus = Math.abs(sm.lWristDev)<10?"good":Math.abs(sm.lWristDev)<20?"warn":"bad";
      sm.trunkStatus = Math.abs(sm.trunkLean)<5?"good":Math.abs(sm.trunkLean)<10?"warn":"bad";
      sm.pelvicStatus = sm.pelvicTilt<3?"good":sm.pelvicTilt<5?"warn":"bad";
      drawSkeleton(result.landmarks[0], sm);
      updateUI(sm);
      _detectFrameId++;
      if (isRecording) { recordFrames.push({ time: ts, metrics: { ...sm } }); }
      if (isCheckingReadiness) { checkReadiness(result.landmarks[0]); }
    } catch (e) {
      console.error('detectLoop error:', e);
    }
  } else {
    ctx.clearRect(0, 0, overlay.width, overlay.height);
    if (isCheckingReadiness) {
      readinessFailStreak++;
      if (readinessFailStreak > 10) { readinessPassCount = 0; readinessFailStreak = 0; }
      updateReadinessUI(null);
    }
  }
}

// =============================================================================
// 15-SECOND MEASUREMENT (with readiness check)
// =============================================================================

// Entry point: show readiness overlay first (or skip for 'all')
function startMeasurement30() {
  measurementData = [];
  isMeasuring = false;

  const area = selectedArea || 'all';

  // 'all' ã‚¨ãƒªã‚¢ã¯readinessã‚¹ã‚­ãƒƒãƒ— â€” ã‚¹ã‚±ãƒ«ãƒˆãƒ³ãŒå‡ºã¦ã„ã‚Œã°ååˆ†
  if (area === 'all') {
    beginCountdownAndMeasure();
    return;
  }

  isCheckingReadiness = true;
  readinessPassCount = 0;
  readinessFailStreak = 0;

  const checks = READINESS_CHECKS[area] || READINESS_CHECKS.all;
  const rOverlay = document.getElementById('readinessOverlay');
  const rChecks = document.getElementById('readinessChecks');
  const rTitle = document.getElementById('readinessTitle');
  const rHint = document.getElementById('readinessHint');
  const rCancel = document.getElementById('btnCancelReadiness');

  rTitle.textContent = 'ãƒã‚¸ã‚·ãƒ§ãƒ³ç¢ºèªä¸­';
  rHint.textContent = 'å¿…è¦ãªéƒ¨ä½ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„';
  rCancel.style.display = '';
  let html = '';
  for (const check of checks) {
    html += `<div class="readiness-item" data-label="${check.label}">
      <span class="ri-icon">â—‹</span><span>${check.label}</span>
    </div>`;
  }
  rChecks.innerHTML = html;
  rOverlay.style.display = 'flex';
}

// Check if a landmark is visible: use visibility if available, else check coordinates are in-frame
function lmVisible(landmarks, idx, threshold) {
  const lm = landmarks[idx];
  if (!lm) return false;
  // If model provides visibility, use it; lite model often returns undefined/0
  if (typeof lm.visibility === 'number' && lm.visibility > 0.01) {
    return lm.visibility >= threshold;
  }
  // Fallback: landmark is "visible" if its coordinates are within the frame (0-1 range with margin)
  return lm.x > 0.02 && lm.x < 0.98 && lm.y > 0.02 && lm.y < 0.98;
}

// Called from detectLoop each frame while isCheckingReadiness
function checkReadiness(landmarks) {
  const area = selectedArea || 'all';
  const checks = READINESS_CHECKS[area] || READINESS_CHECKS.all;
  let allPass = true;

  // 'all' ã‚¨ãƒªã‚¢: ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ãŒå­˜åœ¨ã™ã‚Œã°å…¨ãƒã‚§ãƒƒã‚¯ã‚’ãƒ‘ã‚¹ã¨ã¿ãªã™
  // ï¼ˆã‚¹ã‚±ãƒ«ãƒˆãƒ³ãŒæç”»ã•ã‚Œã¦ã„ã‚‹ = ååˆ†ãªæ¤œå‡ºãŒã‚ã‚‹ï¼‰
  const forcePass = (area === 'all') && landmarks && landmarks.length > 0;

  const items = document.querySelectorAll('#readinessChecks .readiness-item');
  checks.forEach((check, i) => {
    const pass = forcePass || (check.anyOf
      ? check.landmarks.some(idx => lmVisible(landmarks, idx, check.threshold))
      : check.landmarks.every(idx => lmVisible(landmarks, idx, check.threshold)));
    if (items[i]) {
      items[i].classList.toggle('pass', pass);
      items[i].querySelector('.ri-icon').textContent = pass ? 'âœ“' : 'â—‹';
    }
    if (!pass) allPass = false;
  });

  const hint = document.getElementById('readinessHint');
  if (!allPass) {
    const missing = checks.filter((_, i) => !items[i]?.classList.contains('pass'));
    hint.textContent = missing.map(c => c.label).join('ãƒ»') + ' ãŒè¦‹ãˆã¾ã›ã‚“';
    // è“„ç©å¼: é€£ç¶šå¤±æ•—ãŒ10å›è¶…ãˆãŸã‚‰ãƒªã‚»ãƒƒãƒˆã€ãã‚Œä»¥å¤–ã¯ã‚«ã‚¦ãƒ³ãƒˆç¶­æŒ
    readinessFailStreak++;
    if (readinessFailStreak > 10) {
      readinessPassCount = 0;
      readinessFailStreak = 0;
    }
  } else {
    readinessPassCount++;
    readinessFailStreak = 0;
    hint.textContent = 'OK â€” ãã®ã¾ã¾å‹•ã‹ãªã„ã§ãã ã•ã„â€¦';
  }

  if (readinessPassCount >= READINESS_PASS_NEEDED) {
    isCheckingReadiness = false;
    // Brief OK flash then start countdown
    document.getElementById('readinessTitle').textContent = '';
    document.getElementById('readinessChecks').innerHTML = '<div class="readiness-ok">OK!</div>';
    document.getElementById('readinessHint').textContent = '';
    document.getElementById('btnCancelReadiness').style.display = 'none';
    setTimeout(() => {
      document.getElementById('readinessOverlay').style.display = 'none';
      beginCountdownAndMeasure();
    }, 600);
  }
}

// Called when no landmarks detected during readiness
function updateReadinessUI() {
  const items = document.querySelectorAll('#readinessChecks .readiness-item');
  items.forEach(item => {
    item.classList.remove('pass');
    item.querySelector('.ri-icon').textContent = 'â—‹';
  });
  document.getElementById('readinessHint').textContent = 'äººç‰©ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ â€” ã‚«ãƒ¡ãƒ©ã®å‰ã«ç«‹ã£ã¦ãã ã•ã„';
}

// Cancel readiness
function cancelReadiness() {
  isCheckingReadiness = false;
  readinessPassCount = 0;
  readinessFailStreak = 0;
  document.getElementById('readinessOverlay').style.display = 'none';
}

// The actual countdown + 15s measurement
function beginCountdownAndMeasure() {
  measurementData = [];
  isMeasuring = false;
  const mOverlay = document.getElementById('measureOverlay');
  const countdown = document.getElementById('measureCountdown');
  const timer = document.getElementById('measureTimer');
  const progress = document.getElementById('measureProgress');
  mOverlay.style.display = 'flex';
  timer.style.display = 'none';
  countdown.style.display = 'block';
  let count = 3;
  countdown.textContent = count;
  const countInterval = setInterval(() => {
    count--;
    if (count > 0) { countdown.textContent = count; }
    else {
      clearInterval(countInterval);
      countdown.style.display = 'none';
      timer.style.display = 'block';
      isMeasuring = true;
      measureStartTime = performance.now();
      // å‰å›ã®intervalãŒæ®‹ã£ã¦ã„ãŸã‚‰ã‚¯ãƒªã‚¢ï¼ˆäºŒé‡èµ·å‹•é˜²æ­¢ï¼‰
      if (_activeDataInterval) clearInterval(_activeDataInterval);
      let _lastCollectedFrame = -1;
      const dataCollectInterval = setInterval(() => {
        if (smoothedMetrics && _detectFrameId !== _lastCollectedFrame) {
          _lastCollectedFrame = _detectFrameId;
          measurementData.push({ time: performance.now() - measureStartTime, metrics: { ...smoothedMetrics } });
        }
      }, 50); // 50msé–“éš”ï¼ˆ10fpsæ¤œå‡ºã‚’ç¢ºå®Ÿã«æ‹¾ã†ï¼‰
      _activeDataInterval = dataCollectInterval;
      const measureInterval = setInterval(() => {
        const elapsed = (performance.now() - measureStartTime) / 1000;
        timer.textContent = Math.floor(elapsed) + 'ç§’ / 15ç§’';
        progress.style.width = (elapsed / 15 * 100) + '%';
        if (elapsed >= 15) {
          clearInterval(measureInterval);
          clearInterval(dataCollectInterval);
          _activeDataInterval = null;
          isMeasuring = false;
          mOverlay.style.display = 'none';
          countdown.style.display = 'block';
          countdown.textContent = '';
          timer.style.display = 'none';
          progress.style.width = '0%';
          try {
            generateReport();
          } catch (e) {
            console.error('generateReport error:', e);
            const inlineReport = document.getElementById('inlineReport');
            inlineReport.innerHTML = `<div style="margin:16px;padding:16px;background:rgba(255,82,82,0.15);border-radius:12px;border:1px solid var(--red);">
              <div style="font-weight:700;color:var(--red);margin-bottom:8px;">ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼</div>
              <div style="font-size:12px;color:var(--text-dim);">åé›†ãƒ•ãƒ¬ãƒ¼ãƒ : ${measurementData.length}<br>ã‚¨ãƒ©ãƒ¼: ${e.message}</div>
            </div>`;
            inlineReport.style.display = 'block';
          }
        }
      }, 100);
    }
  }, 1000);
}

// =============================================================================
// REPORT GENERATION
// =============================================================================
// æŒ‡æ¨™åˆ¥SDé–¾å€¤ï¼ˆå®‰å®šæ€§100%â†’0%ã®ã‚¹ã‚±ãƒ¼ãƒ«ä¸Šé™ï¼‰
const SD_THRESHOLDS = {
  cva: 5, headTilt: 8, headRot: 20,
  lShoulderElev: 5, shoulderSym: 5,
  rElbowAbd: 25, lElbowAngle: 15, lWristDev: 10,
  trunkLean: 5, pelvicTilt: 4
};

// IQRæ³•ã§å¤–ã‚Œå€¤ã‚’é™¤å¤–ã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
function getCleanIndices(values) {
  const sorted = [...values].sort((a,b) => a - b);
  const n = sorted.length;
  const q1 = sorted[Math.floor(n * 0.25)];
  const q3 = sorted[Math.floor(n * 0.75)];
  const iqr = q3 - q1;
  const lo = q1 - 1.5 * iqr;
  const hi = q3 + 1.5 * iqr;
  const clean = [];
  for (let i = 0; i < values.length; i++) {
    if (values[i] >= lo && values[i] <= hi) clean.push(i);
  }
  return clean;
}

function calcStats(metricKeys) {
  const stats = {};
  // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨: å„ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã©ã®æŒ‡æ¨™ã§å¤–ã‚Œå€¤ã‹ã‚’è¨˜éŒ²
  const perFrameOutliers = new Array(measurementData.length).fill(0); // ãƒ“ãƒƒãƒˆãƒ•ãƒ©ã‚°çš„ã«ä½¿ã‚ãšã€ã‚«ã‚¦ãƒ³ãƒˆ

  for (const key of metricKeys) {
    const def = METRIC_DEFS[key];
    const rawValues = measurementData.map(f => def.getValue(f.metrics));
    // æŒ‡æ¨™ã”ã¨ã«ç‹¬ç«‹ã—ã¦IQRå¤–ã‚Œå€¤ã‚’æ¤œå‡º
    const cleanIdx = getCleanIndices(rawValues);
    const cleanSet = new Set(cleanIdx);
    const outlierIdx = [];
    for (let i = 0; i < rawValues.length; i++) {
      if (!cleanSet.has(i)) { outlierIdx.push(i); perFrameOutliers[i]++; }
    }
    const values = cleanIdx.map(i => rawValues[i]);
    const outliers = outlierIdx.length;
    if (values.length === 0) {
      stats[key] = { values: rawValues, cleanValues: rawValues, mean:0, min:0, max:0, sd:0, cv:0, stability:0, worstTime:0, worstValue:0, status:'warn', direction:'', outliers, outlierIdx };
      continue;
    }
    const mean = values.reduce((a,b)=>a+b,0)/values.length;
    const min = Math.min(...values);
    const max = Math.max(...values);
    const sd = Math.sqrt(values.reduce((s,v)=>s+(v-mean)**2,0)/values.length);
    const cv = mean!==0?(sd/Math.abs(mean))*100:0;
    const maxSD = SD_THRESHOLDS[key] || 10;
    const stability = Math.max(0, Math.round(100 * (1 - sd / maxSD)));
    // æœ€æ‚ªãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆã‚¯ãƒªãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿å†…ï¼‰
    let worstIdx = cleanIdx[0];
    if (key === 'cva') {
      let worstVal = Infinity;
      for (const i of cleanIdx) { if (rawValues[i] < worstVal) { worstVal = rawValues[i]; worstIdx = i; } }
    } else {
      let worstVal = -Infinity;
      for (const i of cleanIdx) { if (rawValues[i] > worstVal) { worstVal = rawValues[i]; worstIdx = i; } }
    }
    const worstTime = measurementData[worstIdx]?.time/1000||0;
    const worstValue = rawValues[worstIdx];
    // åˆ¤å®šã¯ä¸­å¤®ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆã‚¯ãƒªãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿ä¸­å¤®ï¼‰
    const midCleanIdx = cleanIdx[Math.floor(cleanIdx.length/2)];
    const midMetrics = measurementData[midCleanIdx].metrics;
    const status = def.getStatus(midMetrics);
    let direction = '';
    if (def.getDirection && mean > 2) {
      direction = def.getDirection(midMetrics);
    }
    stats[key] = { values: rawValues, cleanValues: values, mean, min, max, sd, cv, stability, worstTime, worstValue, status, direction, outliers, outlierIdx };
  }
  stats._perFrameOutliers = perFrameOutliers;
  stats._totalFrames = measurementData.length;
  return stats;
}

function generateReport() {
  // ã‚½ãƒ¼ãƒˆ + é‡è¤‡æ’é™¤ï¼ˆåŒä¸€detectFrameã‹ã‚‰2å›åé›†ã•ã‚ŒãŸå ´åˆã¸ã®é˜²å¾¡ï¼‰
  measurementData.sort((a, b) => a.time - b.time);
  const deduped = [measurementData[0]];
  for (let i = 1; i < measurementData.length; i++) {
    if (Math.abs(measurementData[i].time - measurementData[i-1].time) > 15) {
      deduped.push(measurementData[i]);
    }
  }
  measurementData = deduped.filter(Boolean);

  if (measurementData.length === 0) {
    const inlineReport = document.getElementById('inlineReport');
    inlineReport.innerHTML = `<div style="margin:16px;padding:16px;background:rgba(255,215,64,0.15);border-radius:12px;border:1px solid var(--yellow);">
      <div style="font-weight:700;color:var(--yellow);margin-bottom:8px;">ãƒ‡ãƒ¼ã‚¿ãŒåé›†ã§ãã¾ã›ã‚“ã§ã—ãŸ</div>
      <div style="font-size:12px;color:var(--text-dim);line-height:1.6;">
        15ç§’é–“ã«ãƒãƒ¼ã‚ºãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚<br>
        ãƒ»ã‚«ãƒ¡ãƒ©ã«ä¸ŠåŠèº«ãŒæ˜ ã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„<br>
        ãƒ»æ˜ã‚‹ã„å ´æ‰€ã§è©¦ã—ã¦ãã ã•ã„<br>
        ãƒ»FPSè¡¨ç¤ºãŒ0ã§ãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„
      </div>
      <button class="btn btn-primary" style="margin-top:12px;width:100%;" onclick="this.closest('div[id]').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>`;
    inlineReport.style.display = 'block';
    return;
  }
  const isAll = selectedArea === 'all';
  const metricKeys = getActiveMetrics();
  const stats = calcStats(metricKeys);
  // åŠ é‡ç·åˆã‚¹ã‚³ã‚¢: å§¿å‹¢åˆ¤å®š(60%) + å®‰å®šæ€§(40%)
  const POSTURE_SCORES = { good: 100, warn: 60, bad: 20 };
  const overallScore = metricKeys.reduce((s, k) => {
    const ps = POSTURE_SCORES[stats[k].status] || 60;
    return s + ps * 0.6 + stats[k].stability * 0.4;
  }, 0) / metricKeys.length;
  const overallStability = metricKeys.reduce((s,k)=>s+stats[k].stability,0)/metricKeys.length;
  // 1ã¤ä»¥ä¸Šã®æŒ‡æ¨™ã§å¤–ã‚Œå€¤ã ã£ãŸãƒ•ãƒ¬ãƒ¼ãƒ æ•°
  const perFrameOutliers = stats._perFrameOutliers || [];
  const outlierCount = perFrameOutliers.filter(c => c > 0).length;
  let html = '';

  // Score card
  const easy = isEasyMode();
  const scoreColor = overallScore>=75?'var(--green)':overallScore>=45?'var(--yellow)':'var(--red)';
  const scoreLabel = easy
    ? (overallScore>=75?'ãƒãƒƒãƒãƒªï¼ğŸŒŸ':overallScore>=45?'ã‚‚ã†ã¡ã‚‡ã£ã¨ï¼ğŸ’ª':'ãŒã‚“ã°ã‚ã†ï¼ğŸ”¥')
    : (overallScore>=75?'è‰¯å¥½':overallScore>=45?'è¦æ”¹å–„':'è¦æ³¨æ„');
  const scoreBg = overallScore>=75?'rgba(0,230,118,0.15)':overallScore>=45?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
  const areaLabel = isAll ? 'å…¨èº«' : FOCUS_AREAS[selectedArea].label;
  const scoreTitleLabel = easy ? 'ã—ã›ã„ã®ã‚¹ã‚³ã‚¢' : 'ç·åˆã‚¹ã‚³ã‚¢';
  const outlierNote = !easy && outlierCount > 0 ? ` / å¤–ã‚Œå€¤${outlierCount}ãƒ•ãƒ¬ãƒ¼ãƒ é™¤å¤–` : '';
  html += `<div class="report-score-card">
    <div class="report-score-value" style="color:${scoreColor}">${Math.round(overallScore)}</div>
    <div class="report-score-label">${scoreTitleLabel}ï¼ˆ${areaLabel}ï¼‰</div>
    <div class="report-score-sub" style="background:${scoreBg};color:${scoreColor}">${scoreLabel}${easy ? '' : ` â€” ${measurementData.length}ãƒ•ãƒ¬ãƒ¼ãƒ  / 15ç§’é–“${outlierNote}`}</div>
  </div>`;

  // Worst metricï¼ˆçµ±åˆã‚¹ã‚³ã‚¢ãŒæœ€ä½ã®æŒ‡æ¨™ï¼‰
  let worstKey = metricKeys[0], worstCombo = Infinity;
  for (const k of metricKeys) {
    const combo = (POSTURE_SCORES[stats[k].status]||60)*0.6 + stats[k].stability*0.4;
    if (combo < worstCombo) { worstCombo = combo; worstKey = k; }
  }
  const ws = stats[worstKey];
  if (easy) {
    html += `<div class="report-worst"><h3>ã„ã¡ã°ã‚“ãã‚’ã¤ã‘ãŸã„ã¨ã“ã‚ ğŸ‘€</h3><p>${getMetricName(worstKey)}ãŒã™ã“ã—ä¸å®‰å®šã ã£ãŸã‚ˆã€‚ã“ã“ã‚’æ„è­˜ã—ã¦ã¿ã‚ˆã†ï¼</p></div>`;
  } else {
    html += `<div class="report-worst"><h3>æœ€ã‚‚ä¸å®‰å®šãªãƒã‚¤ãƒ³ãƒˆ</h3><p>${METRIC_DEFS[worstKey].name}ãŒ${ws.worstTime.toFixed(1)}ç§’æ™‚ç‚¹ã§${ws.worstValue.toFixed(1)}${METRIC_DEFS[worstKey].unit}ã«åˆ°é”ã€‚å¤‰å‹•ä¿‚æ•°${ws.cv.toFixed(1)}%ã€å®‰å®šæ€§${ws.stability.toFixed(0)}%ã€‚</p></div>`;
  }

  if (isAll) {
    // === FULL BODY MODE: area-by-area summary ===
    html += `<div style="font-size:13px;font-weight:700;margin:16px 0 8px;">éƒ¨ä½åˆ¥ã‚¹ã‚³ã‚¢</div>`;
    // Calculate per-area scores and sort by worst first
    const areaScores = [];
    for (const [akey, area] of Object.entries(FOCUS_AREAS)) {
      const areaMetrics = area.metrics;
      const areaStab = areaMetrics.reduce((s,k)=>s+stats[k].stability,0)/areaMetrics.length;
      const areaCombo = areaMetrics.reduce((s,k) => s + (POSTURE_SCORES[stats[k].status]||60)*0.6 + stats[k].stability*0.4, 0) / areaMetrics.length;
      const worstStatus = areaMetrics.some(k=>stats[k].status==='bad') ? 'bad' : areaMetrics.some(k=>stats[k].status==='warn') ? 'warn' : 'good';
      areaScores.push({ key: akey, area, stability: areaStab, combo: areaCombo, status: worstStatus });
    }
    areaScores.sort((a,b) => a.combo - b.combo);

    // è…°ãŒæ¨å®šå€¤ã ã£ãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆmeasurementDataã®éåŠæ•°ã§åˆ¤å®šï¼‰
    const hipEstimatedCount = measurementData.filter(f => f.metrics.hipEstimated).length;
    const isHipEstimated = hipEstimatedCount > measurementData.length * 0.5;

    for (const as of areaScores) {
      const ac = as.status==='good'?'var(--green)':as.status==='warn'?'var(--yellow)':'var(--red)';
      const al = easy
        ? getStatusLabel(as.status)
        : (as.status==='good'?'è‰¯å¥½':as.status==='warn'?'æ³¨æ„':'è¦æ”¹å–„');
      const ab = as.status==='good'?'rgba(0,230,118,0.15)':as.status==='warn'?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
      const isTrunkArea = as.key === 'trunk';
      const estNote = (isTrunkArea && isHipEstimated) ? `<div style="font-size:10px;color:var(--text-dim);margin-top:4px;">* è…°ãŒç”»é¢å¤–ã®ãŸã‚æ¨å®šå€¤ã§ã™ã€‚æ­£ç¢ºã«æ¸¬å®šã™ã‚‹ã«ã¯ã€Œä½“å¹¹ãƒ»éª¨ç›¤ã€ãƒ¢ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„</div>` : '';
      html += `<div class="report-metric" style="border-left:3px solid ${ac};">
        <div class="report-metric-header">
          <div class="report-metric-name">${as.area.icon} ${as.area.label}${isTrunkArea && isHipEstimated ? ' (æ¨å®š)' : ''}</div>
          <div style="font-size:11px;padding:2px 8px;border-radius:4px;background:${ab};color:${ac};font-weight:700;">${al}</div>
        </div>${estNote}
        <div class="report-metric-stats">
          <div class="report-stat"><div class="report-stat-val" style="color:${ac}">${Math.round(as.combo)}</div><div class="report-stat-label">ã‚¹ã‚³ã‚¢</div></div>
          <div class="report-stat"><div class="report-stat-val">${as.area.metrics.length}</div><div class="report-stat-label">æŒ‡æ¨™æ•°</div></div>
          <div class="report-stat"><div class="report-stat-val">${as.area.metrics.filter(k=>stats[k].status!=='good').length}</div><div class="report-stat-label">å•é¡Œæ•°</div></div>
        </div>`;
      // Show each metric in this area briefly
      for (const mk of as.area.metrics) {
        const ms = stats[mk]; const md = METRIC_DEFS[mk];
        const mc = ms.status==='good'?'var(--green)':ms.status==='warn'?'var(--yellow)':'var(--red)';
        html += `<div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-top:1px solid var(--card-border);margin-top:4px;">
          <span style="font-size:12px;">${getMetricName(mk)}</span>
          <span style="font-size:13px;font-weight:700;font-family:monospace;color:${mc};">${ms.mean.toFixed(1)}${md.unit}${ms.direction ? ' ('+ms.direction+')' : ''}</span>
        </div>`;
      }
      // "è©³ã—ãåˆ†æ" button
      if (as.status !== 'good') {
        html += `<div class="report-area-btn" data-area="${as.key}">
          <div class="rab-left"><div class="rab-icon">${as.area.icon}</div><div class="rab-name">${easy ? 'ã‚‚ã£ã¨ãã‚ã—ãè¦‹ã‚‹' : 'ã“ã®éƒ¨ä½ã‚’è©³ã—ãåˆ†æã™ã‚‹'}</div></div>
          <div style="color:var(--blue);font-size:16px;">â€º</div>
        </div>`;
      }
      html += `</div>`;
    }

    // All 10 metrics detail with charts
    html += `<div style="font-size:13px;font-weight:700;margin:16px 0 8px;">${easy ? 'ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ã“ã†ã‚‚ã' : 'å…¨æŒ‡æ¨™ã®æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿'}</div>`;
    for (const key of metricKeys) {
      const def = METRIC_DEFS[key]; const s = stats[key];
      const sc = s.status==='good'?'var(--green)':s.status==='warn'?'var(--yellow)':'var(--red)';
      const sl = getStatusLabel(s.status);
      const sb = s.status==='good'?'rgba(0,230,118,0.15)':s.status==='warn'?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
      const stabColor = s.stability>=80?'var(--green)':s.stability>=50?'var(--yellow)':'var(--red)';
      const stabBg = s.stability>=80?'rgba(0,230,118,0.15)':s.stability>=50?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
      const outlierNote = !easy && s.outliers > 0 ? `<div style="font-size:10px;color:var(--text-dim);margin-top:2px;">å¤–ã‚Œå€¤${s.outliers}ãƒ•ãƒ¬ãƒ¼ãƒ é™¤å¤–</div>` : '';
      html += `<div class="report-metric" style="border-left:3px solid ${sc};">
        <div class="report-metric-header">
          <div class="report-metric-name">${getMetricName(key)}</div>
          <div style="display:flex;gap:4px;align-items:center;">
            <div style="font-size:10px;padding:2px 6px;border-radius:4px;background:${sb};color:${sc};font-weight:700;">å§¿å‹¢:${sl}</div>
            <div style="font-size:10px;padding:2px 6px;border-radius:4px;background:${stabBg};color:${stabColor};font-weight:700;">å®‰å®š:${s.stability}%</div>
          </div>
        </div>
        <div class="report-metric-stats">
          <div class="report-stat"><div class="report-stat-val" style="color:${sc}">${s.mean.toFixed(1)}${def.unit}${s.direction ? ' '+s.direction : ''}</div><div class="report-stat-label">å¹³å‡å€¤</div></div>
          <div class="report-stat"><div class="report-stat-val">${s.min.toFixed(1)}ã€œ${s.max.toFixed(1)}</div><div class="report-stat-label">ç¯„å›²</div></div>
          <div class="report-stat"><div class="report-stat-val">SD ${s.sd.toFixed(1)}</div><div class="report-stat-label">æ¨™æº–åå·®</div></div>
        </div>${outlierNote}
        <canvas class="report-chart" id="chart-${key}" width="400" height="60"></canvas>
      </div>`;
    }
  } else {
    // === SPECIFIC AREA MODE: detailed per-metric analysis ===
    const da = FOCUS_AREAS[selectedArea].deepAnalysis;
    const overviewText = easy ? (da.easyOverview || da.overview) : da.overview;
    html += `<div class="report-metric" style="border-left:3px solid var(--blue);"><div style="font-size:13px;line-height:1.6;color:var(--text-dim);">${overviewText}</div></div>`;
    for (const key of metricKeys) {
      const def = METRIC_DEFS[key]; const s = stats[key]; const md = da.metrics[key];
      const sc = s.status==='good'?'var(--green)':s.status==='warn'?'var(--yellow)':'var(--red)';
      const sl = getStatusLabel(s.status);
      const sb = s.status==='good'?'rgba(0,230,118,0.15)':s.status==='warn'?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
      const advice = easy
        ? (s.status==='good'?(md.easyGoodAdvice||md.goodAdvice):s.status==='warn'?(md.easyWarnAdvice||md.warnAdvice):(md.easyBadAdvice||md.badAdvice))
        : (s.status==='good'?md.goodAdvice:s.status==='warn'?md.warnAdvice:md.badAdvice);
      const tips = easy ? (md.easyTips || md.tips) : md.tips;
      const metricName = easy ? getMetricName(key) : md.name;
      const stabColor2 = s.stability>=80?'var(--green)':s.stability>=50?'var(--yellow)':'var(--red)';
      const stabBg2 = s.stability>=80?'rgba(0,230,118,0.15)':s.stability>=50?'rgba(255,215,64,0.15)':'rgba(255,82,82,0.15)';
      html += `<div class="report-metric" style="border-left:3px solid ${sc};">
        <div class="report-metric-header">
          <div class="report-metric-name">${metricName}</div>
          <div style="display:flex;gap:4px;align-items:center;">
            <div style="font-size:10px;padding:2px 6px;border-radius:4px;background:${sb};color:${sc};font-weight:700;">å§¿å‹¢:${sl}</div>
            <div style="font-size:10px;padding:2px 6px;border-radius:4px;background:${stabBg2};color:${stabColor2};font-weight:700;">å®‰å®š:${s.stability}%</div>
          </div>
        </div>
        <div class="report-metric-stats">
          <div class="report-stat"><div class="report-stat-val" style="color:${sc}">${s.mean.toFixed(1)}${def.unit}${s.direction ? ' '+s.direction : ''}</div><div class="report-stat-label">å¹³å‡å€¤</div></div>
          <div class="report-stat"><div class="report-stat-val">${s.min.toFixed(1)}ã€œ${s.max.toFixed(1)}</div><div class="report-stat-label">ç¯„å›²</div></div>
          <div class="report-stat"><div class="report-stat-val">SD ${s.sd.toFixed(1)}</div><div class="report-stat-label">æ¨™æº–åå·®</div></div>
        </div>
        <canvas class="report-chart" id="chart-${key}" width="400" height="60"></canvas>
        <div class="report-advice"><strong>${easy ? 'ã²ã¨ã“ã¨:' : 'è©•ä¾¡:'}</strong> ${advice}</div>
        <div style="margin-top:8px;"><strong style="font-size:11px;color:var(--text);">${easy ? 'ã‚„ã£ã¦ã¿ã‚ˆã†:' : 'æ”¹å–„ã®ãƒ’ãƒ³ãƒˆ:'}</strong><ul style="margin:4px 0 0 16px;">${tips.map(t=>`<li style="font-size:11px;color:var(--text-dim);line-height:1.6;">${t}</li>`).join('')}</ul></div>
        ${easy ? '' : `<div class="report-ref">${md.ref}</div>`}
      </div>`;
    }
  }

  // Action buttons
  html += `<div class="report-actions">
    <button class="btn btn-primary" id="btnRetryMeasure" style="flex:1;">ã‚‚ã†ä¸€åº¦æ¸¬å®š</button>
    <button class="btn" id="btnExportData" style="flex:1;">ãƒ‡ãƒ¼ã‚¿æ›¸ãå‡ºã—</button>
    <button class="btn" id="btnReportBack" style="flex:1;">${isAll ? 'ãƒˆãƒƒãƒ—ã«æˆ»ã‚‹' : 'åˆ¥ã®éƒ¨ä½ã‚’åˆ†æ'}</button>
  </div>`;

  // Show report inline below camera on the live screen
  const inlineReport = document.getElementById('inlineReport');
  inlineReport.innerHTML = `<div style="margin-top:12px;padding-top:12px;border-top:2px solid var(--blue);">
    <div style="font-size:14px;font-weight:700;margin-bottom:12px;color:var(--blue);">æ¸¬å®šçµæœ</div>
    ${html}
  </div>`;
  inlineReport.style.display = 'block';
  // Switch to metrics tab to show the report
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector('.tab[data-panel="metrics"]').classList.add('active');
  document.getElementById('metricsPanel').style.display = 'block';
  document.getElementById('historyPanel').style.display = 'none';
  document.getElementById('infoPanel').style.display = 'none';
  // Scroll to the report
  setTimeout(() => {
    inlineReport.scrollIntoView({ behavior: 'smooth', block: 'start' });
    for (const key of metricKeys) drawMiniChart(key, stats[key]);
  }, 50);
  document.getElementById('btnRetryMeasure')?.addEventListener('click', () => {
    inlineReport.style.display = 'none';
    inlineReport.innerHTML = '';
  });
  document.getElementById('btnExportData')?.addEventListener('click', () => {
    exportMeasurementData(metricKeys, stats);
  });
  document.getElementById('btnReportBack')?.addEventListener('click', () => {
    if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
    running = false; smoothedMetrics = null; navigateTo('select');
  });
  // Wire up "ã“ã®éƒ¨ä½ã‚’è©³ã—ãåˆ†æ" buttons
  document.querySelectorAll('.report-area-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
      running = false; smoothedMetrics = null;
      selectedArea = btn.dataset.area;
      buildGuideContent();
      navigateTo('guide');
    });
  });
}

function exportMeasurementData(metricKeys, stats) {
  const now = new Date();
  const dateStr = now.getFullYear() + '-' + String(now.getMonth()+1).padStart(2,'0') + '-' + String(now.getDate()).padStart(2,'0');
  const timeStr = String(now.getHours()).padStart(2,'0') + ':' + String(now.getMinutes()).padStart(2,'0');
  const areaLabel = (selectedArea === 'all') ? 'å…¨èº«' : FOCUS_AREAS[selectedArea]?.label || selectedArea;
  const perFrameOutliers = stats._perFrameOutliers || [];
  const outlierCount = perFrameOutliers.filter(c => c > 0).length;

  let txt = '';
  txt += '=== ãƒã‚¤ã‚ªãƒªãƒ³å§¿å‹¢åˆ†æ æ¸¬å®šãƒ‡ãƒ¼ã‚¿ ===\n';
  txt += 'æ—¥æ™‚: ' + dateStr + ' ' + timeStr + '\n';
  txt += 'ã‚¨ãƒªã‚¢: ' + areaLabel + '\n';
  txt += 'ç·ãƒ•ãƒ¬ãƒ¼ãƒ æ•°: ' + measurementData.length + '\n';
  if (outlierCount > 0) txt += 'å¤–ã‚Œå€¤é™¤å¤–: ' + outlierCount + 'ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆIQRæ³•ï¼‰\n';
  txt += 'è¨ˆæ¸¬æ™‚é–“: 15ç§’\n\n';

  // æŒ‡æ¨™ã®å®šç¾©ãƒ»ç¬¦å·è¦ç´„
  txt += '--- æŒ‡æ¨™ã®å®šç¾© ---\n';
  const signDefs = {
    cva: 'è€³-è‚©è§’åº¦ã€‚>53Â°æ­£å¸¸, 48-53Â°æ³¨æ„, <48Â°è­¦å‘Šã€‚å¤§ãã„ã»ã©è‰¯ã„',
    headTilt: 'é ­éƒ¨å´æ–¹å‚¾æ–œã€‚æ­£=å³å‚¾æ–œ, è² =å·¦å‚¾æ–œã€‚|å€¤|<5Â°æ­£å¸¸',
    headRot: 'é ­éƒ¨å›æ—‹æ¨å®šã€‚æ­£=å·¦å›æ—‹, è² =å³å›æ—‹ã€‚|å€¤|<15Â°æ­£å¸¸',
    lShoulderElev: 'å·¦è‚©æŒ™ä¸Šã€‚ä½“å¹¹é•·ã«å¯¾ã™ã‚‹å·¦å³è‚©é«˜å·®ã®æ¯”ç‡(%)ã€‚<3%æ­£å¸¸',
    shoulderSym: 'è‚©é«˜å·¦å³éå¯¾ç§°ã€‚atan2(é«˜ä½å·®,è‚©å¹…)ã€‚<5Â°æ­£å¸¸',
    rElbowAbd: 'å³è‚˜å¤–è»¢ã€‚å‚ç›´ä¸‹å‘ãã‹ã‚‰ã®è§’åº¦ã€‚<45Â°æ­£å¸¸',
    lElbowAngle: 'å·¦è‚˜è§’åº¦ã€‚è‚©-è‚˜-æ‰‹é¦–ã®å†…è§’ï¼ˆå°=æ›²ãŒã‚Šå¤§ï¼‰ã€‚20-70Â°æ­£å¸¸',
    lWristDev: 'å·¦æ‰‹é¦–åä½ã€‚ç›´ç·š(180Â°)ã‹ã‚‰ã®åå·®ã€‚<10Â°æ­£å¸¸',
    trunkLean: 'ä½“å¹¹å´æ–¹å‚¾æ–œã€‚æ­£=å³å‚¾æ–œ, è² =å·¦å‚¾æ–œã€‚|å€¤|<5Â°æ­£å¸¸',
    pelvicTilt: 'éª¨ç›¤æ°´å¹³ã€‚å·¦å³è…°é«˜å·®ã®è§’åº¦ã€‚<3Â°æ­£å¸¸'
  };
  for (const key of metricKeys) {
    const def = METRIC_DEFS[key];
    txt += def.name + '(' + def.unit + '): ' + (signDefs[key] || def.detail) + '\n';
  }
  txt += '\n';

  // ç·åˆã‚¹ã‚³ã‚¢
  txt += '--- ã‚µãƒãƒªãƒ¼ ---\n';
  const POSTURE_SCORES = { good: 100, warn: 60, bad: 20 };
  const overallScore = metricKeys.reduce((s, k) => {
    return s + (POSTURE_SCORES[stats[k].status]||60)*0.6 + stats[k].stability*0.4;
  }, 0) / metricKeys.length;
  txt += 'ç·åˆã‚¹ã‚³ã‚¢: ' + Math.round(overallScore) + ' (å§¿å‹¢60%+å®‰å®šæ€§40%ã®åŠ é‡)\n';
  txt += 'å®‰å®šæ€§ã‚¹ã‚³ã‚¢ç®—å‡º: SDåŸºæº–ï¼ˆæŒ‡æ¨™ã”ã¨ã®è¨±å®¹SDä¸Šé™ã«å¯¾ã™ã‚‹æ¯”ç‡ï¼‰\n\n';

  for (const key of metricKeys) {
    const def = METRIC_DEFS[key];
    const s = stats[key];
    txt += def.name + ':\n';
    txt += '  å¹³å‡: ' + s.mean.toFixed(1) + def.unit + (s.direction ? ' (' + s.direction + ')' : '') + '\n';
    txt += '  ç¯„å›²: ' + s.min.toFixed(1) + ' ã€œ ' + s.max.toFixed(1) + def.unit;
    txt += ' (æœ€æ‚ª: ' + s.worstValue.toFixed(1) + def.unit + ' @ ' + s.worstTime.toFixed(1) + 'ç§’)\n';
    txt += '  SD: ' + s.sd.toFixed(2) + '  å®‰å®šæ€§: ' + s.stability + '%';
    txt += '  (è¨±å®¹SDä¸Šé™: ' + (SD_THRESHOLDS[key]||10) + ')\n';
    txt += '  å§¿å‹¢åˆ¤å®š: ' + s.status;
    if (s.outliers > 0) txt += '  å¤–ã‚Œå€¤: ' + s.outliers + 'ãƒ•ãƒ¬ãƒ¼ãƒ é™¤å¤–';
    txt += '\n\n';
  }

  // å…¨ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿
  txt += '--- æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ï¼ˆå…¨ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰ ---\n';
  txt += '# å„ã‚»ãƒ«ã®*å° = ãã®æŒ‡æ¨™ã§å¤–ã‚Œå€¤ï¼ˆIQRæ³•ã€çµ±è¨ˆã‹ã‚‰é™¤å¤–ï¼‰\n';
  txt += 'æ™‚åˆ»(s)';
  for (const key of metricKeys) {
    txt += '\t' + METRIC_DEFS[key].name + '(' + METRIC_DEFS[key].unit + ')';
  }
  txt += '\n';

  // å„æŒ‡æ¨™ã®å¤–ã‚Œå€¤ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’Setã«å¤‰æ›
  const outlierSets = {};
  for (const key of metricKeys) {
    outlierSets[key] = new Set(stats[key].outlierIdx || []);
  }

  for (let i = 0; i < measurementData.length; i++) {
    const f = measurementData[i];
    txt += (f.time / 1000).toFixed(2);
    for (const key of metricKeys) {
      const val = METRIC_DEFS[key].getValue(f.metrics);
      const mark = outlierSets[key].has(i) ? '*' : '';
      txt += '\t' + (typeof val === 'number' ? val.toFixed(1) : '--') + mark;
    }
    txt += '\n';
  }

  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  const blob = new Blob([txt], { type: 'text/plain; charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = dateStr + '_å§¿å‹¢åˆ†æ_' + areaLabel + '.txt';
  a.click();
  URL.revokeObjectURL(url);
}

function drawMiniChart(key, stat) {
  const canvas = document.getElementById('chart-'+key);
  if (!canvas) return;
  const c = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const values = stat.values;
  if (values.length < 2) return;
  const pad = 4;
  const mn = stat.min-(stat.max-stat.min)*0.1;
  const mx = stat.max+(stat.max-stat.min)*0.1;
  const range = mx-mn||1;
  const meanY = h-pad-((stat.mean-mn)/range)*(h-pad*2);
  c.strokeStyle='rgba(255,255,255,0.15)';
  c.setLineDash([4,4]);
  c.beginPath(); c.moveTo(0,meanY); c.lineTo(w,meanY); c.stroke();
  c.setLineDash([]);
  const color = stat.status==='good'?'#00e676':stat.status==='warn'?'#ffd740':'#ff5252';
  c.strokeStyle = color;
  c.lineWidth = 1.5;
  c.beginPath();
  const step = Math.max(1, Math.floor(values.length/w));
  for (let i=0; i<values.length; i+=step) {
    const x=(i/(values.length-1))*w;
    const y=h-pad-((values[i]-mn)/range)*(h-pad*2);
    if (i===0) c.moveTo(x,y); else c.lineTo(x,y);
  }
  c.stroke();
  c.lineTo(w,h); c.lineTo(0,h); c.closePath();
  const fc = color.replace(')',',0.1)').replace('#','');
  // Convert hex to rgba for fill
  const r=parseInt(color.slice(1,3),16), g=parseInt(color.slice(3,5),16), b=parseInt(color.slice(5,7),16);
  c.fillStyle = `rgba(${r},${g},${b},0.1)`;
  c.fill();
}

// =============================================================================
// SNAPSHOT & RECORDING (preserved from v2)
// =============================================================================
function captureSnapshot(metricsOverride) {
  const snapCanvas = document.createElement("canvas");
  snapCanvas.width = video.videoWidth; snapCanvas.height = video.videoHeight;
  const sctx = snapCanvas.getContext("2d");
  sctx.save();
  if (facingMode === "user") { sctx.translate(snapCanvas.width,0); sctx.scale(-1,1); }
  sctx.drawImage(video,0,0); sctx.restore();
  if (facingMode === "user") { sctx.save(); sctx.translate(snapCanvas.width,0); sctx.scale(-1,1); }
  sctx.drawImage(overlay,0,0);
  if (facingMode === "user") sctx.restore();
  const dataUrl = snapCanvas.toDataURL("image/jpeg", 0.85);
  const metrics = metricsOverride || (smoothedMetrics ? { ...smoothedMetrics } : null);
  const now = new Date();
  const timeStr = now.getHours().toString().padStart(2,"0")+":"+now.getMinutes().toString().padStart(2,"0")+":"+now.getSeconds().toString().padStart(2,"0");
  snapshots.unshift({ time: timeStr, image: dataUrl, metrics });
  renderHistory();
}

function startRecording() {
  if (isRecording) return;
  isRecording = true; recordStartTime = performance.now(); recordFrames = [];
  recordingBadge.style.display = "block"; btnRecord.textContent = "éŒ²ç”»ä¸­..."; btnRecord.classList.add("recording");
  setTimeout(() => stopRecording(), 5000);
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false; recordingBadge.style.display = "none"; btnRecord.textContent = "éŒ²ç”» 5ç§’"; btnRecord.classList.remove("recording");
  if (recordFrames.length > 0) {
    const avg = {};
    const keys=["cva","headTilt","headRot","lShoulderElev","shoulderSym","rElbowAbd","lElbowAngle","lWristDev","trunkLean","pelvicTilt","rula"];
    for (const k of keys) avg[k]=recordFrames.reduce((s,f)=>s+(f.metrics[k]||0),0)/recordFrames.length;
    avg.cvaStatus=avg.cva>53?"good":avg.cva>48?"warn":"bad";
    avg.headTiltStatus=Math.abs(avg.headTilt)<5?"good":Math.abs(avg.headTilt)<10?"warn":"bad";
    avg.headRotStatus=Math.abs(avg.headRot)<15?"good":Math.abs(avg.headRot)<30?"warn":"bad";
    avg.lShoulderStatus=avg.lShoulderElev<3?"good":avg.lShoulderElev<6?"warn":"bad";
    avg.shoulderSymStatus=avg.shoulderSym<5?"good":avg.shoulderSym<10?"warn":"bad";
    avg.rElbowStatus=avg.rElbowAbd<45?"good":avg.rElbowAbd<60?"warn":"bad";
    avg.lElbowStatus=(avg.lElbowAngle>=20&&avg.lElbowAngle<=70)?"good":((avg.lElbowAngle>=10&&avg.lElbowAngle<20)||(avg.lElbowAngle>70&&avg.lElbowAngle<=90))?"warn":"bad";
    avg.lWristStatus=Math.abs(avg.lWristDev)<10?"good":Math.abs(avg.lWristDev)<20?"warn":"bad";
    avg.trunkStatus=Math.abs(avg.trunkLean)<5?"good":Math.abs(avg.trunkLean)<10?"warn":"bad";
    avg.pelvicStatus=avg.pelvicTilt<3?"good":avg.pelvicTilt<5?"warn":"bad";
    avg.rElbowAboveShoulder=recordFrames[recordFrames.length-1].metrics.rElbowAboveShoulder;
    captureSnapshot(avg);
  }
}

function renderHistory() {
  const list = document.getElementById("historyList");
  if (snapshots.length===0) { list.innerHTML='<div style="color:var(--text-dim);font-size:13px;text-align:center;padding:40px 0;">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>'; return; }
  const statusColor=(s)=>s==="good"?"var(--green)":s==="warn"?"var(--yellow)":"var(--red)";
  list.innerHTML = snapshots.map(snap => {
    const m=snap.metrics; if (!m) return "";
    const rc=m.rula<=2?"var(--green)":m.rula<=4?"var(--yellow)":m.rula<=6?"#ff9100":"var(--red)";
    return `<div class="snapshot-card"><img src="${snap.image}" class="snapshot-img" alt="snapshot"><div class="snapshot-header"><div class="snapshot-time">${snap.time}</div><div class="snapshot-rula" style="color:${rc}">RULA ${m.rula.toFixed(1)}</div></div><div class="snapshot-body"><div class="snapshot-metrics">
      <div class="snapshot-metric"><span>CVA</span><span style="color:${statusColor(m.cvaStatus)}">${m.cva.toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>é ­éƒ¨å‚¾æ–œ</span><span style="color:${statusColor(m.headTiltStatus)}">${Math.abs(m.headTilt).toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>é ­éƒ¨å›æ—‹</span><span style="color:${statusColor(m.headRotStatus)}">${Math.abs(m.headRot).toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>å·¦è‚©æŒ™ä¸Š</span><span style="color:${statusColor(m.lShoulderStatus)}">${m.lShoulderElev.toFixed(1)}%</span></div>
      <div class="snapshot-metric"><span>è‚©å·¦å³å·®</span><span style="color:${statusColor(m.shoulderSymStatus)}">${m.shoulderSym.toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>å¼“è…•å¤–è»¢</span><span style="color:${statusColor(m.rElbowStatus)}">${m.rElbowAbd.toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>å·¦è‚˜è§’</span><span style="color:${statusColor(m.lElbowStatus)}">${m.lElbowAngle.toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>å·¦æ‰‹é¦–åä½</span><span style="color:${statusColor(m.lWristStatus)}">${m.lWristDev.toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>ä½“å¹¹å‚¾æ–œ</span><span style="color:${statusColor(m.trunkStatus)}">${Math.abs(m.trunkLean).toFixed(1)}Â°</span></div>
      <div class="snapshot-metric"><span>éª¨ç›¤å‚¾æ–œ</span><span style="color:${statusColor(m.pelvicStatus)}">${m.pelvicTilt.toFixed(1)}Â°</span></div>
    </div></div></div>`;
  }).join("");
}

// =============================================================================
// EVENT HANDLERS
// =============================================================================
document.getElementById('btnFullScan').addEventListener('click', () => {
  selectedArea = 'all';
  buildGuideContent();
  navigateTo('guide');
});

document.getElementById('btnStartAnalysis').addEventListener('click', () => {
  if (!poseLandmarker) { alert("ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã‚’å¾…ã£ã¦ãã ã•ã„"); return; }
  buildMetricCards();
  navigateTo('live');
  startCamera();
  setTimeout(setupPiP, 500);
  // Auto-start 15s measurement in full scan mode
  if (selectedArea === 'all') {
    const waitForCamera = setInterval(() => {
      if (running) { clearInterval(waitForCamera); setTimeout(startMeasurement30, 500); }
    }, 200);
  }
});

document.getElementById('btnBackToSelect').addEventListener('click', () => navigateTo('select'));

document.getElementById('btnBackFromLive').addEventListener('click', () => {
  cancelReadiness();
  if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
  running = false; smoothedMetrics = null;
  navigateTo('select');
});

cameraSelect.addEventListener("change", (e) => {
  facingMode = e.target.value; running = false; smoothedMetrics = null; startCamera();
});

btnRecord.addEventListener("click", () => { if (!isRecording) startRecording(); });
btnSnapshot.addEventListener("click", () => { captureSnapshot(null); });

document.getElementById('btnMeasure30').addEventListener('click', () => { startMeasurement30(); });
document.getElementById('btnCancelReadiness').addEventListener('click', () => { cancelReadiness(); });

// Tab switching
document.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    tab.classList.add("active");
    const panel = tab.dataset.panel;
    document.getElementById("metricsPanel").style.display = panel==="metrics"?"block":"none";
    document.getElementById("historyPanel").style.display = panel==="history"?"block":"none";
    document.getElementById("infoPanel").style.display = panel==="info"?"block":"none";
  });
});

// =============================================================================
// VIEW MODE TOGGLE
// =============================================================================
function applyViewMode() {
  const btns = document.querySelectorAll('#viewToggle .view-toggle-btn');
  btns.forEach(b => b.classList.toggle('active', b.dataset.mode === viewMode));
  // Rebuild metric cards if on live screen
  if (currentScreen === 'live' && selectedArea) {
    buildMetricCards();
    if (smoothedMetrics) updateUI(smoothedMetrics);
  }
  // Rebuild inline report if visible
  const inlineReport = document.getElementById('inlineReport');
  if (inlineReport && inlineReport.style.display === 'block' && measurementData.length > 0) {
    generateReport();
  }
}

document.getElementById('viewToggle').addEventListener('click', (e) => {
  const btn = e.target.closest('.view-toggle-btn');
  if (!btn || btn.dataset.mode === viewMode) return;
  viewMode = btn.dataset.mode;
  localStorage.setItem('vp-viewMode', viewMode);
  applyViewMode();
});

// =============================================================================
// BOOT
// =============================================================================
applyViewMode();
buildFocusGrid();
init();

</script>
</body>
</html>
